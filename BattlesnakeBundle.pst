<?xml version="1.0"?><st-source><!-- Name: Battlesnake BundleBundleName: Battlesnake BundleBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'HTTP' '') #(#any 'Xtreams-Transforms' '') #(#any 'SiouX-Server' '') #(#any 'AppeX-Core' '') #(#any 'SUnit' '') #(#any 'SUnitToo' ''))Parcel: nilParcelName: Battlesnake BundlePrerequisiteDescriptions: #(#(#name 'HTTP' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'SiouX-Server' #componentType #bundle) #(#name 'AppeX-Core' #componentType #package) #(#name 'SUnit' #componentType #package) #(#name 'SUnitToo' #componentType #package))PrerequisiteParcels: #(#('HTTP' '') #('Xtreams-Transforms' '') #('SiouX-Server' '') #('AppeX-Core' '') #('SUnit' '') #('SUnitToo' '') #('SiouX-Server' '') #('Xtreams-Transforms' '') #('AppeX-Core' '') #('SiouX-Tools' '') #('AppeX-Tools' '') #('SUnit' '') #('SUnitToo' ''))Version: 2.05 - competitionDate: 9:01:21 PM March 4, 2017 --><time-stamp>From VisualWorksÂ®, 8.2.1 of January 19, 2017 on March 4, 2017 at 9:01:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Battlesnake</name><environment>Smalltalk</environment><private>false</private><imports>			private Core.*			</imports><category></category><attributes><package>Battlesnake</package></attributes></name-space><class><name>GameTest</name><environment>Battlesnake</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports>			private Net.*			private SiouX.*			private Xtreams.*			</imports><category></category><attributes><package>Battlesnake-Tests</package></attributes></class><class><name>BoardTest</name><environment>Battlesnake</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake-Tests</package></attributes></class><class><name>SnakeTest</name><environment>Battlesnake</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board snake </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake-Tests</package></attributes></class><class><name>Snake</name><environment>Battlesnake</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>head snakeName board segments liveStatus kills color headUrl lastPosition health snakeId rewardPaths trail neighbours </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><comment><class-id>Battlesnake.Snake</class-id><body>Snake has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	board	&lt;AlphaCompositedImage | Board | FlowLine | FlowParagraph | FlowSegment | GraphicsMedium | Grid | Label | LayoutSizedOrigin | OrderedDither | PixelArray | RasterOp | Rectangle | SimpleStringLabel | TextLines | WindowOpenPositionToolModel&gt;	description of board	bubble	&lt;Collection&gt;	description of bubble	head	&lt;AbstractBinaryObjectStorage | BoardTile | ByteCodeStream | DatabaseField | EncodedStream | GenericSettingDescriptor | MenuItem | MenuItemInsertion | NullStream | PathNode | PositionableStream | PostgresLOB | ProgressWidgetSpec | RBErrorAction | ReadStream | RectangleEdge | SettingsManagerPage | StandardIOStream | SyntaxErrorException | TextCollector | TileContent | UnsupportedCharacterError | WriteStream&gt;	description of head	segments	&lt;SequenceableCollection&gt;	description of segments	snakeName	&lt;JavascriptCode | MessageForwarder | Object | ProtoObject | ProtoObject&gt;	description of snakeNameStrategy:1) Receive board state2) Parse the board for food and snakes (boardtile with boardtile contents, and snake objects)3) Slither:Do I have a path?	ifTrue:[		Has the path changed?		ifTrue:[Snake findPathTo: (Snake findTarget).]					]	ifFalse:[Snake findPathTo: (Snake findTarget).	]	Snake move - moves to first tile in path instance variable, and decreases path to move first tile.Method: slither - returns selfMethod: findTarget - returns a tile	calls methods:	- findFoodTile - returns foodTile or nil	- findSmallsnakeTile - returns tile or nil	- runAwayFrom:aTile - returns safetyTile or nil	- findPerimeter - return clear wall tile on farthest wall (if width is &gt; 50% of width of board) or nearest wall (remember bubble tiles!)Method: findPathTo: aTile -- returns a pathMethod: snake move -- returns selfInstance variable: addWiggle(boolean) - adds additional tiles to your path</body></comment><class><name>Medusa</name><environment>Battlesnake</environment><super>Battlesnake.Snake</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path bubble target nextMove currentBehavior possibleTiles previousBehavior targetEdge taunt goldCoins </inst-vars><class-inst-vars>tauntSelector </class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><comment><class-id>Battlesnake.Medusa</class-id><body>Medusa has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables:	path	&lt;OrderedCollection of &lt;Tile&gt;&gt;	path I am about to take.	strategies	&lt;OrderedCollection&gt;	collection of blocks that when evaluated, will determine the next behaviour.</body></comment><class><name>TileContent</name><environment>Battlesnake</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tile </inst-vars><class-inst-vars></class-inst-vars><imports>			Xtreams.*			</imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>SnakePart</name><environment>Battlesnake</environment><super>Battlesnake.TileContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>snake nextSegment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>Reward</name><environment>Battlesnake</environment><super>Battlesnake.TileContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>EmptySpace</name><environment>Battlesnake</environment><super>Battlesnake.TileContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>Wall</name><environment>Battlesnake</environment><super>Battlesnake.TileContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>TestObstacle</name><environment>Battlesnake</environment><super>Battlesnake.TileContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake-Tests</package></attributes></class><class><name>Food</name><environment>Battlesnake</environment><super>Battlesnake.Reward</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>Body</name><environment>Battlesnake</environment><super>Battlesnake.SnakePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previousSegment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>Head</name><environment>Battlesnake</environment><super>Battlesnake.SnakePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>GoldCoin</name><environment>Battlesnake</environment><super>Battlesnake.Reward</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>BoardTile</name><environment>Battlesnake</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>north east south west neighbours position content board cachedPaths safeSpace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>Game</name><environment>Battlesnake</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>board medusa gameName turn </inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>PathNode</name><environment>Battlesnake</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tile costFromStart costToTarget parentNode distanceFromStart target costOfTravel costOfRisk </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>Board</name><environment>Battlesnake</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows snakes foods goldCoins walls medusa game </inst-vars><class-inst-vars></class-inst-vars><imports>			Xtreams.*			</imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>WormHole</name><environment>Battlesnake</environment><super>AppeX.Application</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>activeGames </class-inst-vars><imports>			private OS.*			private Xtreams.*			</imports><category></category><attributes><package>Battlesnake</package></attributes></class><class><name>WormHoleClient</name><environment>Battlesnake</environment><super>AppeX.ApplicationClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Battlesnake</package></attributes></class><shared-variable><name>WinningGoldCount</name><environment>Battlesnake</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>4</initializer><attributes><package>Battlesnake</package></attributes></shared-variable><shared-variable><name>HighPassingCost</name><environment>Battlesnake</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>	"	High number representing non-passable content.	"	16rFFFFFFF</initializer><attributes><package>Battlesnake</package></attributes></shared-variable><shared-variable><name>RiskCost</name><environment>Battlesnake</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>100</initializer><attributes><package>Battlesnake</package></attributes></shared-variable><shared-variable><name>Directions</name><environment>Battlesnake</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Dictionary with: (0 @ -1) -&gt; #up with: (0 @ 1) -&gt; #down with: (-1 @ 0) -&gt; #left with: (1 @ 0) -&gt; #right</initializer><attributes><package>Battlesnake</package></attributes></shared-variable><shared-variable><name>StepCost</name><environment>Battlesnake</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>100</initializer><attributes><package>Battlesnake</package></attributes></shared-variable><shared-variable><name>InitialSnakeLength</name><environment>Battlesnake</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>3</initializer><attributes><package>Battlesnake</package></attributes></shared-variable><methods><class-id>Battlesnake.GameTest</class-id> <category>accessing</category><body package="Battlesnake-Tests">hostPortString	^ host, ':', port printString</body><body package="Battlesnake-Tests">newRequestFor: stateData path: path	| request |	request := Net.HttpRequest post: (self urlString: path).	request contents: (WormHole encodeFormData: stateData).	^request</body><body package="Battlesnake-Tests">urlString: path	^ 'http://', self hostPortString, path</body></methods><methods><class-id>Battlesnake.GameTest</class-id> <category>initialize-release</category><body package="Battlesnake-Tests">setUp	| server |	super setUp.	server := SiouX.Server id: 'Battlesnake Server'.	server start.	host := 'localhost'.	port := server listeners first port.</body></methods><methods><class-id>Battlesnake.GameTest</class-id> <category>tests</category><body package="Battlesnake-Tests">endGameState		^ Dictionary with: #game_id -&gt; self exampleGameId</body><body package="Battlesnake-Tests">exampleGameId		^  'b1dadee8-a112-4e0e-afa2-2845cd1f21aa'</body><body package="Battlesnake-Tests">exampleMedusaUUID		^  '2c4d4d70-8cca-48e0-ac9d-03ecafca0c98'</body><body package="Battlesnake-Tests">moveState"	https://stembolthq.github.io/battle_snake/#post-move	(self new moveState)"	^ Dictionary new		add: #you -&gt; self exampleMedusaUUID;		add: #width -&gt; 2;		add: #turn -&gt; 0;		add: #snakes -&gt; (Array			with: (Dictionary new				add: #taunt -&gt; 'git gud';				add: #name -&gt; 'Medusa';				add: #id -&gt; self exampleMedusaUUID;				add: #health_points -&gt; 93;				add: #coords -&gt; #(#(0 0) #(0 0) #(0 0));				yourself)			with: (Dictionary new				add: #taunt -&gt; 'gotta go fast';				add: #name -&gt; 'other-snake';				add: #id -&gt; 'c35dcf26-7f48-492c-b7b5-94ae78fbc713';				add: #health_points -&gt; 50;				add: #coords -&gt; #(#(1 0) #(1 0) #(1 0));				yourself)			);		add: #height -&gt; 2;		add: #game_id -&gt; self exampleGameId;		add: #food -&gt; #(#(1 1));				"Let's ignore dead snakes for now"		yourself</body><body package="Battlesnake-Tests">startGameState		^ Dictionary		with: #game_id -&gt; self exampleGameId		with: #width -&gt; 20		with: #height -&gt; 20</body><body package="Battlesnake-Tests">testGameCreation	| game state |	state := self startGameState.	game := Game fromState: state.		self assert: game medusa class == Medusa.	self assert: game board isEmpty.	self assert: game gameName = (state at: #game_id).	self assert: game board width = (state at: #width).	self assert: game board height = (state at: #height).	self assert: game medusa power = 0.	self assert: game medusa head isNil</body></methods><methods><class-id>Battlesnake.GameTest</class-id> <category>tests - HTTP</category><body package="Battlesnake-Tests">testPostEnd	self runPostStart.	self runPostEnd</body><body package="Battlesnake-Tests">testPostMove	self runPostStart.	self runPostMove</body><body package="Battlesnake-Tests">testPostStart	self runPostStart</body><body package="Battlesnake-Tests">testStartToEnd	WormHole resetGame.	self		runPostStart;		runPostMove;		runPostEnd</body></methods><methods><class-id>Battlesnake.GameTest</class-id> <category>running tests</category><body package="Battlesnake-Tests">runPostEnd	| request response state decoded |	state := self endGameState.	request := self newRequestFor: state path: '/end'.	response := request execute.		self assert: response notNil.	self assert: response isSuccess.	self assert: response contentType = 'application/json'.	decoded := JSON decode: response contents.	self assert: decoded notNil.	self assert: decoded keys sorted = #("status").	"self assert: (decoded at: #status) = 'Game Over'"</body><body package="Battlesnake-Tests">runPostMove	| request response state decoded |	state := self moveState.	request := self newRequestFor: state path: '/move'.	response := request execute.		self assert: response notNil.	self assert: response isSuccess.	self assert: response contentType = 'application/json'.	decoded := JSON decode: response contents.	self assert: decoded notNil.	self assert: decoded keys sorted = #(move "taunt")</body><body package="Battlesnake-Tests">runPostStart	"state keysAndValuesDo: [ :key :value | request addFormKey: key value: value ]."	| request response state decoded |	state := self startGameState.	request := self newRequestFor: state path: '/start'.	response := request execute.	self assert: response notNil.	self assert: response isSuccess.	self assert: response contentType = 'application/json'.	decoded := JSON decode: response contents.	self assert: decoded notNil.	self assert: decoded keys sorted = #(#color #head_type #head_url #name  #tail_type)</body></methods><methods><class-id>Battlesnake.BoardTest</class-id> <category>testing</category><body package="Battlesnake-Tests">testBestPath	| board path time |	board := Board defaultBoard.		time := [path := board topLeft findPathTo: board bottomLeft] timeToRun.	"The following assertion will fail if the above code is interrupted by a breakpoint etc."	self assert: time &lt; 100 milliseconds.	self assert: path notNil.	self assert: path size = (board height - 1).	self assert: path last == board bottomLeft.		time := [path := board topLeft findPathTo: board bottomRight] timeToRun.	"The following assertion will fail if the above code is interrupted by a breakpoint etc."	self assert: time &lt; 100 milliseconds.	self assert: path notNil.	self assert: path size = (board height + board width - 2).	self assert: path last == board bottomRight.	self assert: (path allSatisfy: [:eachTile | eachTile isEmpty])</body><body package="Battlesnake-Tests">testBestPathWithObstacles	| board path time |	board := Board defaultBoard.	board		putTestObstacleAt: 0 @ 5;		putTestObstacleAt: 1 @ 5;		putTestObstacleAt: 2 @ 5;		putTestObstacleAt: 3 @ 5;		putTestObstacleAt: 10 @ 4;		putTestObstacleAt: 10 @ 5;		putTestObstacleAt: 10 @ 6;		putTestObstacleAt: 19 @ 15;		putTestObstacleAt: 18 @ 15;		putTestObstacleAt: 17 @ 15;		putTestObstacleAt: 16 @ 15;		putTestObstacleAt: 15 @ 15;		putTestObstacleAt: 14 @ 15;		putTestObstacleAt: 14 @ 16;		putTestObstacleAt: 17 @ 19;		putTestObstacleAt: 17 @ 18;		putTestObstacleAt: 17 @ 17.		time := [path := board topLeft findPathTo: board bottomRight] timeToRun.	self assert: time &lt; 100 milliseconds.	self assert: path last == board bottomRight.	time := [path := board topRight findPathTo: board bottomRight] timeToRun.	self assert: time &lt; 100 milliseconds.	self assert: path last == board bottomRight.	time := [path := board topRight findPathTo: board bottomLeft] timeToRun.	self assert: time &lt; 100 milliseconds.	self assert: path last == board bottomLeft.	time := [path := board topLeft findPathTo: board bottomLeft] timeToRun.	self assert: time &lt; 100 milliseconds.	self assert: path last == board bottomLeft.</body><body package="Battlesnake-Tests">testCorners	| board dimensions tile neighbor |	board := Board defaultBoard.	dimensions := board dimensions.		"Test upper-left tile:"	tile := board at: 0@0.	self assert: tile north isNil.	self assert: tile west isNil.	neighbor := tile east.	self assert: neighbor notNil.	self assert: neighbor west == tile.	neighbor := tile south.	self assert: neighbor notNil.	self assert: neighbor north == tile.		"Test upper-right tile:"	tile := board at: (dimensions x - 1) @ 0.	self assert: tile north isNil.	self assert: tile east isNil.	neighbor := tile west.	self assert: neighbor notNil.	self assert: neighbor east == tile.	neighbor := tile south.	self assert: neighbor notNil.	self assert: neighbor north == tile.		"Test bottom-right tile:"	tile := board at: (dimensions x - 1) @ (dimensions y - 1).	neighbor := tile north.		self assert: neighbor notNil.	self assert: neighbor south == tile.	self assert: tile east isNil.	neighbor := tile west.	self assert: neighbor notNil.	self assert: neighbor east == tile.	self assert: tile south isNil.	"Test bottom-left tile:"	tile := board at: 0 @ (dimensions y - 1).	neighbor := tile north.		self assert: neighbor notNil.	self assert: neighbor south == tile.	self assert: tile west isNil.	neighbor := tile east.	self assert: neighbor notNil.	self assert: neighbor west == tile.	self assert: tile south isNil.</body><body package="Battlesnake-Tests">testExampleBoard	| board |		board := Board exampleBoard.		self assert: board snakes notEmpty.	self assert: board foods notEmpty.</body><body package="Battlesnake-Tests">testInsideNeighbours	| board dimensions tile |	dimensions := 20 @ 20.	board := Board width: dimensions x height: dimensions y.		1 to: dimensions x - 2 do: [ :x |		1 to: dimensions y - 2 do: [ :y |			tile := board at: x @ y.			self assert: tile neighbours size = 4.			self assert: tile north south == tile.			self assert: tile east west == tile.			self assert: tile south north == tile.			self assert: tile west east == tile.			self assert: tile north east south west == tile.			self assert: tile north west south east == tile.			self assert: tile south east north west == tile.			self assert: tile south west north east == tile.			]		]</body><body package="Battlesnake-Tests">testNodeDistances	| board size node |	size := 20 @ 20.	board := Board width: size x height: size y.	node := PathNode		on: board topLeft		target: board bottomRight .		self assert: node distanceToTarget = (size x + size y - 2)</body><body package="Battlesnake-Tests">testSimplePath	|myBoard path start end |		myBoard:= Board defaultBoard.		(Array		with: ((2 @ 3) corner: (7 @ 7))		with: ((10 @ 15) corner: (7 @ 7))		with: ((2 @ 15) corner: (7 @ 7))		with: ((10 @ 3) corner: (7 @ 7))) do: [ :rectangle |			start := myBoard at: rectangle origin.			end := myBoard at: rectangle corner.			path := start simplePathTo: end.			self assert: path size = (start distanceTo: end)						]</body></methods><methods><class-id>Battlesnake.SnakeTest</class-id> <category>initialize-release</category><body package="Battlesnake-Tests">setUp	super setUp.	board := Board defaultBoard</body><body package="Battlesnake-Tests">tearDown	board := nil.	^ super tearDown</body></methods><methods><class-id>Battlesnake.SnakeTest</class-id> <category>tests</category><body package="Battlesnake-Tests">testMedusaBubble	| coordinates bubble bubbleShift |	coordinates := #(#(3 5) #(3 6) #(3 7) #(4 7)).	snake := Medusa on: board.	snake updateCoordinates: coordinates.	bubble := snake bubble.	self assert: bubble size &gt; 0.		bubbleShift := snake bubbleShift.	self assert: bubbleShift class == Point.	self assert: (bubbleShift x between: -1 and: 1).	self assert: (bubbleShift y between: -1 and: 1).</body><body package="Battlesnake-Tests">testNewSnake	| head |	snake := Snake on: board.	self assert: snake head isNil.	self assert: snake segments isEmpty.	self assert: snake tail isNil.		snake updateCoordinates: #(#(3, 5)).		head := snake head.	self assert: head notNil.	self assert: head class == Head.	self assert: head isSnakePart.	self assert: head isSnakeHead. 	self assert: head tile position = (3 @ 5).	self assert: snake power = 1.	self assert: snake tail == head.	self assert: head tailLength = 0</body><body package="Battlesnake-Tests">testSnakeBody	| coordinates head count tail |	coordinates := #(#(3 5) #(3 6) #(3 7) #(4 7)).	snake := Snake on: board.	snake updateCoordinates: coordinates.	head := snake head.	tail := snake tail.		self assert: head notNil.	self assert: head class == Head.	self assert: head isSnakePart.	self assert: head isSnakeHead.	self assert: head isSnakeBody not.	self assert: head position = (coordinates first first @ coordinates first last).	self assert: snake power = coordinates size.	count := 0.		snake segments with: coordinates do: [ :segment :coord |		count := count + 1.		self assert: segment position = (coord first @ coord last).		self assert: segment tailLength = (snake power - count).		].		self assert: tail ~~ head.	self assert: tail position = (coordinates last first @ coordinates last last).	self assert: tail class == Body.	self assert: tail isSnakePart.	self assert: tail isSnakeBody.	self assert: tail isSnakeHead not.	self assert: tail tailLength = 0.</body><body package="Battlesnake-Tests">testSnakeFindFood	| game medusa |		game := Game exampleGame.	board := game board.	medusa := game medusa.		medusa findFood.		self assert: medusa currentBehavior = #findFood.</body></methods><methods><class-id>Battlesnake.Snake</class-id> <category>accessing</category><body package="Battlesnake">appendBody: aBody	| part |	part := segments last.	part nextSegment: aBody.	aBody previousSegment: part.	aBody snake: self.	segments add: aBody.</body><body package="Battlesnake">board	^board</body><body package="Battlesnake">board: aBoard	board := aBoard</body><body package="Battlesnake">closestFood	^ head tile closestFood</body><body package="Battlesnake">closestGold	^ head tile closestGold</body><body package="Battlesnake">closestSnake	^ head tile closestSnake</body><body package="Battlesnake">distanceTo: contentOrTile	^ (contentOrTile position - self position) battlesnakeDistance</body><body package="Battlesnake">emptyTiles	^ self neighbours select: #isEmpty</body><body package="Battlesnake">enemySnakes	^ board snakes select: [ :each | each ~= self ]</body><body package="Battlesnake">ensurePartAt: index	| part count |	segments size &gt;= index ifTrue: [^segments at: index].	index = 1		ifTrue: 			[head ifNil: [self head: self newHead].			part := head]		ifFalse: 			[count := 1.			part := head.			[count &lt; index] whileTrue: 					[part nextSegment ifNil: [self appendBody: self newBody].					part := part nextSegment.					count := count + 1]].	^part</body><body package="Battlesnake">findPathTo: tileOrContent	^ head findPathTo: tileOrContent</body><body package="Battlesnake">findRewardPaths	| rewards answer |	answer := Set new.		rewards := Set new		addAll: board goldCoins;		addAll: board foods;		yourself.		rewards do: [ :eachReward |		(self findPathTo: eachReward) ifNotNil: [ :path |			answer add: eachReward -&gt; path ]		].		^ answer sorted: [ :rp1 :rp2 |			rp1 value size &lt;= rp2 value size			]</body><body package="Battlesnake">head	^head</body><body package="Battlesnake">head: aHead	head := aHead.	aHead snake: self.	segments := OrderedCollection with: head.</body><body package="Battlesnake">lastPosition	^lastPosition</body><body package="Battlesnake">lastPosition: aTile	lastPosition := aTile</body><body package="Battlesnake">length	^ self segments size</body><body package="Battlesnake">neighbours	^ neighbours ifNil: [ neighbours := self tile neighbours sorted: [ :a :b |			a safeSpace size &gt; b safeSpace size			]		]</body><body package="Battlesnake">newBody	^Body new</body><body package="Battlesnake">newHead	^Head new</body><body package="Battlesnake">pastTail	trail size &lt;= 3 ifTrue: [ ^ self tail ].	^ trail at: (trail size - self length)</body><body package="Battlesnake">position	^ head position</body><body package="Battlesnake">power	^ self length</body><body package="Battlesnake">rewardPathTo: aReward	^ self rewardPaths		detect: [ :each | each key == aReward]		ifNone: [ nil ]</body><body package="Battlesnake">rewardPaths"	Make sure that rewardPaths is initialized to be a sorted collection	of associations where the keys are the rewards (food or gold or whatever)	and each corresponding value is a collection of tiles leading to that reward."	^ rewardPaths ifNil: [ rewardPaths := self findRewardPaths ].</body><body package="Battlesnake">segments	| answer part |	part := head.	answer := OrderedCollection new.	[ part notNil ] whileTrue: [		answer add: part.		part := part nextSegment.		].	^answer</body><body package="Battlesnake">snakeId	^snakeId</body><body package="Battlesnake">snakeId: aString	snakeId := aString</body><body package="Battlesnake">snakeName	^snakeName</body><body package="Battlesnake">snakeName: anObject	snakeName := anObject</body><body package="Battlesnake">tail	^ head		ifNil: [ nil ]		ifNotNil: [ self segments last ]</body><body package="Battlesnake">tile"	To ensure polymorphic calculations, we define the tile of a Snake as the tile occupied by its Head."	^ head tile</body><body package="Battlesnake">tilesWithinDistance: distance	^ head tilesWithinDistance: distance</body></methods><methods><class-id>Battlesnake.Snake</class-id> <category>testing</category><body package="Battlesnake">canHunt: anotherSnake	^ self power &gt; anotherSnake power</body><body package="Battlesnake">isDangerToMedusa	^ self isWeakerThanMedusa not</body><body package="Battlesnake">isEnemy	^ true</body><body package="Battlesnake">isMedusa	^ false</body><body package="Battlesnake">isWeakerThanMedusa	^ self power &lt; board medusa power</body><body package="Battlesnake">seesFood	^ self tile neighbours anySatisfy: [ :tile | tile hasFood ]</body><body package="Battlesnake">shouldRunFrom: anotherSnake	^ (self canHunt: anotherSnake) not</body></methods><methods><class-id>Battlesnake.Snake</class-id> <category>actions</category><body package="Battlesnake">resetBubble"	Ordinary snakes don't have bubble, do nothing."</body><body package="Battlesnake">updateSegmentsFrom: points""	| length |	length := points size.	1 to: length do: [ :index |		| part newTile |		part := self ensurePartAt: index.		part tile ifNotNil: [: oldTile | oldTile resetContent].		newTile := board at: (points at: index).		newTile content: part].	trail add: self head tile.</body></methods><methods><class-id>Battlesnake.Snake</class-id> <category>accessing state</category><body package="Battlesnake">jsonState	^ Game jsonEncode: self state</body><body package="Battlesnake">state	^ Dictionary new		at: #name put: self snakeName;		at: #status put: liveStatus;		at: #coords put: (self segments collect: [:each | Array with: each x with: each y]);		at: #kill put: kills;		at: #color put: color;		at: #head_url put: headUrl;		at: #health put: health;		yourself</body><body package="Battlesnake">updateCoordinates: anArray"	anArray will contain #(x, y) arrays representing the tile on which	individual snake segments lie."	self updateSegmentsFrom: (anArray collect: [ :each | each first @ each last])</body><body package="Battlesnake">updateState: aState"	"	self updateCoordinates: (aState at: #coords ifAbsent: [ #()])."		No kills or status in 2017:	kills := (aState at: #kills ifAbsent: [ 0 ]).	liveStatus := (aState at: #status ifAbsent: [ 'alive'])."		health := (aState at: #health_points ifAbsent: [ 100 ]).	rewardPaths := nil.	neighbours := nil</body></methods><methods><class-id>Battlesnake.Snake</class-id> <category>printing</category><body package="Battlesnake">printOn: aStream	aStream nextPutAll: self jsonState</body></methods><methods><class-id>Battlesnake.Snake</class-id> <category>initialize-release</category><body package="Battlesnake">initialize	super initialize.	segments := OrderedCollection new.	liveStatus := 'alive'.	kills := 0.	trail := OrderedCollection new.</body></methods><methods><class-id>Battlesnake.Snake class</class-id> <category>instance creation</category><body package="Battlesnake">new	^ super new initialize</body><body package="Battlesnake">on: aBoard	^ self new		board: aBoard;		yourself</body></methods><methods><class-id>Battlesnake.Snake class</class-id> <category>example snakes</category><body package="Battlesnake-Tests">exampleEnemy1_on: aBoard	"	self exampleEnemy1_on: Board defaultBoard"	^aBoard updateSingleSnakeState: self exampleEnemy1_state myUUID: nil</body><body package="Battlesnake-Tests">exampleEnemy1_state"	self exampleEnemy1_state"	^ Dictionary new		at: #name put: 'Enemy 1';		at: #id put: 'Enemy 1';		at: #coords put: #(#(10 12) #(10 13) #(10 14) #(10 15));		yourself</body><body package="Battlesnake-Tests">exampleEnemy2_on: aBoard	"	self exampleEnemy2_on: Board defaultBoard"	^aBoard updateSingleSnakeState: self exampleEnemy2_state myUUID: nil</body><body package="Battlesnake-Tests">exampleEnemy2_state"	self exampleEnemy2_state"	^ Dictionary new		at: #name put: 'Enemy 2';		at: #id put: 'Enemy 2';		at: #coords put: #(#(11 5) #(11 4) #(10 4) #(10 3) #(10 2) #(11 2) #(12 2) #(13 2));		yourself</body><body package="Battlesnake-Tests">exampleMedusaOn: aBoard"	self exampleMedusaOn: Board defaultBoard"	^(Medusa on: aBoard)		snakeName: Medusa defaultSnakeName;		updateCoordinates: #(#(7 8) #(6 8 ) #(5 8) #(5 9) #(5 10) #(4 10));		yourself</body><body package="Battlesnake-Tests">exampleNoodlezOn: aBoard	"	self exampleNoodlezOn: Board defaultBoard"	^(self on: aBoard)		snakeName: 'Noodlez';		updateCoordinates: #(#(0 0) #(0 1) #(0 2) #(1 2));		yourself</body><body package="Battlesnake-Tests">exampleOn: aBoard	"	self exampleOn: Board defaultBoard"	^(self on: aBoard)		snakeName: 'example-snake';		updateCoordinates: #(#(4 6) #(4 7) #(4 8) #(5 8) #(6 8));		yourself</body><body package="Battlesnake-Tests">exampleSnakes: aBoard	^ Set new		add: (self exampleMedusaOn: aBoard);		add: (self exampleEnemy1_on: aBoard);		add: (self exampleEnemy2_on: aBoard);		yourself</body></methods><methods><class-id>Battlesnake.Medusa</class-id> <category>accessing</category><body package="Battlesnake">boardCentre	^ board centre</body><body package="Battlesnake">bubble	^ bubble ifNil: [ bubble := self tilesWithinDistance: self bubbleSize]</body><body package="Battlesnake">bubbleShift"	Answer a point that should be the direction of the bubble's shift.	All empty tiles have the weight equal to distance from the head.	Tiles with food have larger weight the closer they are to the head."	| sumX sumY sumWeight dX dY shift |		sumX := sumY := sumWeight := 0.		self bubble do: [ :eachTile |		| eachWeight |		eachWeight := 0.		eachTile isEmpty			ifTrue: ["				eachWeight := self distanceTo: eachTile."				eachWeight := 1.				]			ifFalse: [				eachWeight := self bubbleSize + 1 - (self distanceTo: eachTile).			].		eachTile isTraversable ifFalse: [			eachWeight := eachWeight negated.			].		sumX := sumX + (eachTile x * eachWeight).		sumY := sumY + (eachTile y * eachWeight).		sumWeight := sumWeight + eachWeight.		].		dX := (sumX / sumWeight) - head x.	dY := (sumY / sumWeight) - head y.		shift := dX abs &gt; dY abs		ifTrue: [ dX sign @ 0 ]		ifFalse: [ 0 @ dY sign ].				^ shift</body><body package="Battlesnake">bubbleSize"	I am a Medusa. My bubble size is 3 moves ahead."	^ 3</body><body package="Battlesnake">closestCorner	^ head tile closestCorner</body><body package="Battlesnake">closestEdge	^ head tile closestEdge</body><body package="Battlesnake">color	^ color ifNil: [ color := WormHole color]</body><body package="Battlesnake">currentBehavior	^currentBehavior</body><body package="Battlesnake">currentBehavior: selectorOrNil	selectorOrNil		"ifNil: [self halt]"		ifNotNil: [		Transcript nextPutAll: selectorOrNil; space		].	^currentBehavior := selectorOrNil</body><body package="Battlesnake">farthestCorner	^ head tile farthestCorner</body><body package="Battlesnake">farthestEdge	^ head tile farthestEdge</body><body package="Battlesnake">findPathTo: tileOrContent	^ (super findPathTo: tileOrContent) ifNotNil: [ :thePath |		thePath isEmpty ifTrue: [ ^ nil ].		(self possibleTiles includes: thePath first)			ifTrue: [ thePath ]			ifFalse: [ nil ]		]</body><body package="Battlesnake">findPathToTarget	"	Find the best path to my current target."	^ self findPathTo: self target</body><body package="Battlesnake">findRewardPaths	| answer paths enemySnakes |		paths := super findRewardPaths.	answer := paths asOrderedCollection.	enemySnakes := self enemySnakes.		paths do: [ :rewardPath |		| eachTile eachPath |		eachTile := rewardPath key tile.		eachPath := rewardPath value.		eachTile safeSpace size &lt;= self length ifTrue: [			answer remove: rewardPath ifAbsent: []			].		enemySnakes do: [ :eachEnemy |			(eachEnemy findPathTo: eachTile) ifNotNil: [ :enemyPath |				enemyPath size &lt;= eachPath size ifTrue: [					answer remove: rewardPath ifAbsent: []					]				]			]		].		^ answer</body><body package="Battlesnake">findTarget"	Return a Tile or Food (possibly another Snake Head?) based on the current strategy.	For now, just return my tail's neighbor that is not a snake part."	^ self tail neighbours detect: [ :any | any isEmpty ]</body><body package="Battlesnake">health	^ health ifNil: [ 100 ]</body><body package="Battlesnake">nextMove		^ nextMove</body><body package="Battlesnake">nextMoveDirection	^ Directions at: self nextMove ifAbsent: [ Directions any ]</body><body package="Battlesnake">path	^ (path isNil or: [ path isEmpty ])		ifTrue: [ path := self findPathToTarget ]		ifFalse: [ path ]</body><body package="Battlesnake">path: tiles"	Set my path to a collection of Tiles"	path := tiles</body><body package="Battlesnake">possibleTiles	possibleTiles ifNil: [				possibleTiles := self traversableTiles.		possibleTiles isEmpty ifTrue: [			possibleTiles := self emptyTiles.			].		possibleTiles := possibleTiles asArray.		Transcript			nextPutAll: 'Possible tiles: ';			nextPutAll: possibleTiles printString;			cr.		].		^ possibleTiles</body><body package="Battlesnake">snakeId	^ snakeId ifNil: [snakeId := self class snakeId]</body><body package="Battlesnake">target	^target ifNil: [target := self findTarget]</body><body package="Battlesnake">target: aTile	target := aTile</body><body package="Battlesnake">traversableTiles	^ self neighbours select: #isTraversable</body></methods><methods><class-id>Battlesnake.Medusa</class-id> <category>actions</category><body package="Battlesnake">findEnemiesInBubble"	Go through my bubble and for each tile that have a snake part in them that is not me, add that snake to the result."	| enemies |		enemies := Set new.	 self bubble do: [ :eachTile | eachTile snake		ifNotNil: [ :snake | snake ~~ self ifTrue: [ enemies add: snake ]]		].		^ enemies</body><body package="Battlesnake">findFoodsInBubble	| foods |		foods := Set new.	 self bubble do: [ :eachTile | eachTile hasFood ifTrue: [ foods add: eachTile content ]		].		^ foods</body><body package="Battlesnake">moveTo: aTile	| moveTo options |	options := self possibleTiles.	moveTo := (options includes: aTile) ifTrue: [ aTile ].	options isEmpty ifTrue: [ options := self tile neighbours ].	moveTo := moveTo ifNil:  [ options any ].	moveTo hasGold ifTrue: [		goldCoins := goldCoins + 1.		taunt := '*** KA CHING ***'].	moveTo hasFood ifTrue: [ taunt := 'nom nom nom ...'].	^ nextMove := moveTo position - self position</body><body package="Battlesnake">nextPosition	^ self position + self nextMove</body><body package="Battlesnake">resetBubble	bubble := nil</body><body package="Battlesnake">resetPath	path := nil</body></methods><methods><class-id>Battlesnake.Medusa</class-id> <category>accessing state</category><body package="Battlesnake">moveResponseState"	from https://github.com/sendwithus/battlesnake-legacy#response-1 :	{	  'move': 'up',	  'taunt': 'go snake yourself'	}"	^ self stateKeys: #(#move #taunt)</body><body package="Battlesnake">startResponseState"	From https://github.com/sendwithus/battlesnake-legacy#response "	^ self stateKeys: #(#name #color #head_url #taunt #'head_type' #'tail_type')</body><body package="Battlesnake">state	| state |	state := super state		at: #move put: self nextMoveDirection;		yourself.		self taunt ifNotNil: [ :theTaunt | state at: #taunt put: theTaunt ].	state at: #'head_type' put: 'tongue'.	state at: #'tail_type' put: 'curled'.		^ state</body><body package="Battlesnake">stateKeys: aCollection	| state newState |	state := self state.		newState := aCollection collect: [ :each | state associationAt: each ifAbsent: [nil]].	newState := newState reject: #isNil.		^ Dictionary withAll: newState</body><body package="Battlesnake">updateState: aState	path := nil.	possibleTiles := nil.	previousBehavior := self currentBehavior.	self currentBehavior: nil.	nextMove := nil.	taunt := 'Ready for some Smalltalk?'.		super updateState: aState.</body></methods><methods><class-id>Battlesnake.Medusa</class-id> <category>testing</category><body package="Battlesnake">isEnemy	^ false</body><body package="Battlesnake">isMedusa	^ true</body></methods><methods><class-id>Battlesnake.Medusa</class-id> <category>behaviors</category><body package="Battlesnake">avoidTraps		| riskyTiles options |		(options := self possibleTiles) size &lt;= 1 ifTrue: [ ^self ].		riskyTiles := OrderedCollection new: 3.		options do: [ :each |		(each safeSpace size &gt; self length)			ifTrue: [ ^ self ]			ifFalse: [ riskyTiles add: each ]		].	riskyTiles := riskyTiles select: #isEmpty.	riskyTiles isEmpty ifTrue: [ ^ self ].	self currentBehavior: #avoidTraps.	self moveTo: riskyTiles first</body><body package="Battlesnake">behave	"	self		tryBehavior: #snatchWinningGold;		tryBehavior: #avoidTraps."		(board game turn &lt;= 5)		ifTrue: [			self				tryBehavior: #findFood;				tryBehavior: #goToClosestCorner			]		ifFalse: [			self				tryBehavior: #findGold;				tryBehavior: #findFood			].	self		tryBehavior: #findSafestQuadrant;		tryBehavior: #chaseTail;		tryBehavior: #findSafestSpace;		tryBehavior: #goToPerimeter;		tryBehavior: #avoidTraps.		"the last resort"	self tryBehavior: #randomMove</body><body package="Battlesnake">chaseTail	| options tile |		(path := self findPathTo: self tail) ifNil: [^self].	path isEmpty ifTrue: [ ^ self ].	tile := path first.	options := self possibleTiles.	(options includes: tile) ifFalse: [^self].	tile safeSpace size &lt; self length ifTrue: [^self].	self currentBehavior: #chaseTail.	self moveTo: tile.</body><body package="Battlesnake">findFood	"	Return the next move when finding food"	| food options tile rewardPath |	self health &gt; 50 ifTrue: [		taunt := 'Pork with dumplings every day!'.		^self ]."	(self power &gt;= 10 and: [self health &gt; 75]) ifTrue: [^self].	(self power &gt;= 20 and: [self health &gt; 50]) ifTrue: [^self].	(self power &gt;= 30 and: [self health &gt; 30]) ifTrue: [^self]."		(rewardPath := self findPathToReward: Food) ifNil: [^self].	food := rewardPath key.	path := rewardPath value.	(food tile traversableTilesWithinDistance: self length) size &lt; self length ifTrue: [^self].	path isEmpty ifTrue: [^self].	tile := path first.	options := self possibleTiles.	(options includes: tile) ifFalse: [ ^ self ].	self currentBehavior: #findFood.	self health &gt; 30 ifTrue: [taunt := 'Getting hungry...'].	(self health between: 21 and: 30) ifTrue: [taunt := 'Solve world''s hunger!!!'].	(self health between: 11 and: 20) ifTrue: [taunt := 'Really? Is this the way I am going to die?'].	(self health &lt;= 10) ifTrue: [taunt := 'I am metling! I am melting! I am melting!'].	self moveTo: tile</body><body package="Battlesnake">findGold"	Return the next move when finding food"	| gold rewardPath tile options |		self health &lt; 20 ifTrue: [ ^ self ].	self board goldCoins isEmpty ifTrue: [ ^ self ].		(rewardPath := self findPathToReward: GoldCoin) ifNil: [^self].		gold := rewardPath key.	path := rewardPath value.	path isEmpty ifTrue: [ ^ self ].		target := gold.	tile := path first.	tile safeSpace size &lt; self length ifTrue: [ ^ self ].	options := self possibleTiles.	(options includes: tile) ifFalse: [ ^ self ].	self currentBehavior: #findGold.	taunt := 'GOLD! GOLD! GOLD!'.	self moveTo: tile</body><body package="Battlesnake">findPathToReward: aRewardClass	^self rewardPaths		detect: [:eachRewardPath |			eachRewardPath key class = aRewardClass			]		ifNone: [nil]</body><body package="Battlesnake">findSafestQuadrant	"	Return the next move to go to a quadrant with highest count of traversable tiles."	| tiles targetTile center tile |	tiles := board safestQuadrantFor: self.	tiles ifNil: [^self].	tiles isEmpty ifTrue: [^self].	center := (board width / 2 - 1) rounded @ (board height / 2 - 1) rounded.	center := board at: center.	tiles := tiles sorted: [:a :b |		(a distanceTo: center) &lt;= (b distanceTo: center)].	"Pick a tile close enough but a bit removed from the center so I don't block it myself."	targetTile := tiles detect: [ :any | (any distanceTo: center) &gt;= 4 ] ifNone: [ ^ self ].	(path := self findPathTo: targetTile) ifNil: [^self].	path isEmpty ifTrue: [^self].	tile := path first.	(self traversableTiles includes: tile) ifFalse: [^self].	tile safeSpace size &lt; self length ifTrue: [^self].	self currentBehavior: #findSafestQuadrant.	self moveTo: tile</body><body package="Battlesnake">findSafestSpace	"	Return the next move to go to a quadrant with highest count of traversable tiles."	| options first second |	options := self possibleTiles select: #isTraversable.	options isEmpty ifTrue: [^self].	self currentBehavior: #findSafestSpace.	first := options at: 1.	options size = 1 ifTrue: [		^ self moveTo: first		].	second := options at: 2.		first safeSpace size &gt; self length ifTrue: [		^ self moveTo: first ].		first safeSpace size = second safeSpace size ifTrue: [		options := self sortTilesByCountWithinMyLength: (Array with: first with: second).		^ self moveTo: options first.		].	self moveTo: first</body><body package="Battlesnake">goToClosestCorner			(path := self findPathTo: self closestCorner) ifNil: [ ^ self ].	path isEmpty ifTrue: [ ^self ].		self currentBehavior: #goToClosestCorner.	self moveTo: path first.</body><body package="Battlesnake">goToPerimeter"	This strategy method is a placeholder to go the board perimeter."	| edge  |		previousBehavior = #goToPerimeter ifTrue: [				((self distanceTo: targetEdge) &gt; 3) ifTrue: [				edge := targetEdge].		].		edge := edge ifNil: [self farthestCorner].		(self findPathTo: edge) ifNil: [		edge := self farthestEdge.		].		(self findPathTo: edge) ifNil: [		edge := self boardCentre.		].		targetEdge := edge.		(path := self findPathTo: edge) ifNil: [ ^self ].	path isEmpty ifTrue: [ ^self ].		self currentBehavior: #goToPerimeter.	self moveTo: path removeFirst.</body><body package="Battlesnake">randomMove	self currentBehavior: #randomMove.	self emptyTiles isEmpty ifTrue: [		"		I am trapped. Oh well... any move will do.		"		self currentBehavior: #trapped.		^ self moveTo: self neighbours any.		].	self moveTo: self emptyTiles  any</body><body package="Battlesnake">snatchWinningGold	| tile |	(goldCoins + 1) &lt; WinningGoldCount ifTrue: [^self].	tile := self neighbours		detect: [ :anyTile | anyTile hasGold ]		ifNone: [ ^ self ].		self currentBehavior: #snatchWinningGold.	self moveTo: tile</body><body package="Battlesnake">sortTilesByCountWithinMyLength: options	| myLength |	myLength := self length.	^options sorted: 			[:a :b |			(a traversableTilesWithinDistance: myLength) size				&gt; (b traversableTilesWithinDistance: myLength) size]</body><body package="Battlesnake">tryBehavior: aSelector"	Try to execute the behavior specified by aSelector.	If currentBehavior is already set, just return it."	self currentBehavior ifNotNil: [ ^ self currentBehavior ].	self currentBehavior = aSelector ifTrue: [ ^ self currentBehavior ].		self perform: aSelector.		^self currentBehavior</body></methods><methods><class-id>Battlesnake.Medusa</class-id> <category>initialize-release</category><body package="Battlesnake">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	headUrl := WormHole headUrl.	color := WormHole color.	goldCoins := 0.	snakeName := 'Medusa'.</body></methods><methods><class-id>Battlesnake.Medusa class</class-id> <category>accessing</category><body package="Battlesnake">defaultSnakeName	^ 'Medusa'</body><body package="Battlesnake">randomTaunt"	Answer a collection of Strings to be used as taunts during the game.	(self randomTaunt)"	tauntSelector := tauntSelector ifNil: [Random new].		^ self taunts at: (tauntSelector next * self taunts size) ceiling</body><body package="Battlesnake">snakeId	^ '98d61455-ff9d-41d8-b394-960336ef9da3'</body><body package="Battlesnake">taunts"	Answer a collection of Strings to be used as taunts during the game.	(self taunts)"	^ #(		'We will we will STONE you!'		'I am smarter than you are.'		'If I win, you buy beer!'		'I AM ALIVE!!!'		'Trussst in meeee, jussst in meee...'		'la la la la la'		'As simple as possible but not simpler than that'		'Ready for Smalltalk?'		'Let''s have some Smalltalk!'		'Talk Small, or not at all!'		)</body></methods><methods><class-id>Battlesnake.Medusa class</class-id> <category>instance creation</category><body package="Battlesnake">on: aBoard	|myMedusa|	myMedusa := super on: aBoard.	aBoard medusa: myMedusa.	^myMedusa</body></methods><methods><class-id>Battlesnake.TileContent</class-id> <category>accessing</category><body package="Battlesnake">closestSnake	^ tile closestSnake</body><body package="Battlesnake">distanceTo: contentOrTile	^ (contentOrTile position - self position) battlesnakeDistance</body><body package="Battlesnake">findPathTo: tileOrContent	^ tile findPathTo: tileOrContent</body><body package="Battlesnake">neighbours	^ tile neighbours</body><body package="Battlesnake">position	^ tile ifNotNil: [tile position]</body><body package="Battlesnake">snake	^ nil</body><body package="Battlesnake">tile	^tile</body><body package="Battlesnake">tile: aTile	tile := aTile</body><body package="Battlesnake">tilesWithinDistance: distance	^ tile tilesWithinDistance: distance</body><body package="Battlesnake">x	^ tile x</body><body package="Battlesnake">y	^ tile y</body></methods><methods><class-id>Battlesnake.TileContent</class-id> <category>testing</category><body package="Battlesnake">isEmptySpace	^ false</body><body package="Battlesnake">isFood	^ false</body><body package="Battlesnake">isGold	^ false</body><body package="Battlesnake">isObstacle	^ true</body><body package="Battlesnake">isReward	^ false</body><body package="Battlesnake">isSnakeBody	^ false</body><body package="Battlesnake">isSnakeHead	^ false</body><body package="Battlesnake">isSnakePart	^ false</body><body package="Battlesnake">isTraversable	| safe dangerous |		safe := 0.	dangerous := 0.	tile neighbours do: [ :each |		(each isEmpty or: [each hasReward]) ifTrue: [			safe := safe + 1.			].		each hasSnakeHead ifTrue: [			(each snake isMedusa or: [each snake isWeakerThanMedusa])				ifTrue: [ safe := safe + 1 ]				ifFalse: [ dangerous := dangerous + 1]			].		].		^ safe &gt; 1 and: [ dangerous = 0 ]</body><body package="Battlesnake">isWall	^ false</body><body package="Battlesnake">mayBeTraversableIn: futureTurns	^ self isTraversable</body></methods><methods><class-id>Battlesnake.TileContent</class-id> <category>printing</category><body package="Battlesnake">printOn: aStream	aStream nextPutAll: self jsonState</body></methods><methods><class-id>Battlesnake.TileContent</class-id> <category>accessing state</category><body package="Battlesnake">jsonState	^ JSON encode: self state</body><body package="Battlesnake">state	^ self stateDescription</body><body package="Battlesnake">stateDescription	^ self subclassResponsibility</body></methods><methods><class-id>Battlesnake.TileContent class</class-id> <category>instance creation</category><body package="Battlesnake">on: aTile	^ self new		tile: aTile;		yourself</body></methods><methods><class-id>Battlesnake.SnakePart</class-id> <category>accessing</category><body package="Battlesnake">nextSegment	^nextSegment</body><body package="Battlesnake">nextSegment: anObject	nextSegment := anObject</body><body package="Battlesnake">previous	^ nil</body><body package="Battlesnake">snake	^snake</body><body package="Battlesnake">snake: anObject	snake := anObject</body><body package="Battlesnake">tailLength"	The distance from here to the last segment of the Snake.	This will change every time a segment is appended to the snake."	| tailLength segment |	tailLength := 0.	segment := self.	[(segment := segment nextSegment) isNil] whileFalse: [		tailLength := tailLength + 1.		].	^ tailLength</body><body package="Battlesnake">tile: aTile	super tile: aTile.	snake resetBubble</body></methods><methods><class-id>Battlesnake.SnakePart</class-id> <category>testing</category><body package="Battlesnake">isSnakePart	^ true</body><body package="Battlesnake">mayBeTraversableIn: futureTurns	^ self tailLength &lt;= futureTurns</body></methods><methods><class-id>Battlesnake.SnakePart</class-id> <category>accessing state</category><body package="Battlesnake">state	^ super state, ' ', snake snakeName</body></methods><methods><class-id>Battlesnake.Reward</class-id> <category>testing</category><body package="Battlesnake">isObstacle	^ self isTraversable not</body><body package="Battlesnake">isReward	^ true</body></methods><methods><class-id>Battlesnake.Reward</class-id> <category>accessing state</category><body package="Battlesnake">stateDescription	" *** This method was defined by Battlesnake.TileContent as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Battlesnake.EmptySpace</class-id> <category>testing</category><body package="Battlesnake">isEmptySpace	^ true</body><body package="Battlesnake">isObstacle	^ false</body></methods><methods><class-id>Battlesnake.EmptySpace</class-id> <category>accessing state</category><body package="Battlesnake">stateDescription	^ 'empty'</body></methods><methods><class-id>Battlesnake.Wall</class-id> <category>accessing state</category><body package="Battlesnake">isWall	^true</body><body package="Battlesnake">stateDescription	" *** This method was defined by Battlesnake.TileContent as a subclass responsibility.	Replace its body with a proper implementation. *** "^'wall'</body></methods><methods><class-id>Battlesnake.Wall</class-id> <category>testing</category><body package="Battlesnake">isTraversable	^ false</body></methods><methods><class-id>Battlesnake.TestObstacle</class-id> <category>accessing state</category><body package="Battlesnake-Tests">stateDescription		^ 'obstacle'</body></methods><methods><class-id>Battlesnake.Food</class-id> <category>testing</category><body package="Battlesnake">isFood	^ true</body></methods><methods><class-id>Battlesnake.Food</class-id> <category>accessing state</category><body package="Battlesnake">stateDescription	^ 'food'</body></methods><methods><class-id>Battlesnake.Food class</class-id> <category>instance creation</category><body package="Battlesnake-Tests">exampleCoordinates"	Return an Array of Points with the coordinates of food."	^ #(#(2 2) #(13 5) #(16 12) #(7 16 ) #(16 16)) collect: [ :each | each first @ each last]</body></methods><methods><class-id>Battlesnake.Body</class-id> <category>accessing</category><body package="Battlesnake">previousSegment	^previousSegment</body><body package="Battlesnake">previousSegment: anObject	previousSegment := anObject</body></methods><methods><class-id>Battlesnake.Body</class-id> <category>testing</category><body package="Battlesnake">isSnakeBody	^ true</body><body package="Battlesnake">isTraversable"	If I am a snake's tail and the head has no imminent food consumption,	The tile I occupy will be traversable in the next turn."	^ snake length &gt; InitialSnakeLength		and: [ self nextSegment isNil		and: [ self snake seesFood not ]]</body></methods><methods><class-id>Battlesnake.Body</class-id> <category>accessing state</category><body package="Battlesnake">stateDescription	^ 'body'</body></methods><methods><class-id>Battlesnake.Head</class-id> <category>testing</category><body package="Battlesnake">isSnakeHead	^ true</body><body package="Battlesnake">isTraversable	^ self snake isWeakerThanMedusa</body></methods><methods><class-id>Battlesnake.Head</class-id> <category>accessing</category><body package="Battlesnake">areaWithinDistance: distance	^ tile areaWithinDistance: distance</body><body package="Battlesnake">probabilityOfReaching: aTile in: numberOfMoves"	Answer an integer that is used as the percent probablity that I will reach aTile in numberOfMoves.	This is only determined by the potential size of the area, not by presence of any content in the tiles,"	| distance area |		distance := self distanceTo: aTile.	distance &gt; numberOfMoves ifTrue: [ ^0 ].	distance = 0 ifTrue: [^ 10 * StepCost].		area := self areaWithinDistance: distance.		^ (10 * StepCost / area) rounded</body><body package="Battlesnake">tile: aTile	super tile: aTile.	snake lastPosition: aTile</body></methods><methods><class-id>Battlesnake.Head</class-id> <category>accessing state</category><body package="Battlesnake">stateDescription	^ 'head'</body></methods><methods><class-id>Battlesnake.GoldCoin</class-id> <category>accessing state</category><body package="Battlesnake">isGold	^true</body><body package="Battlesnake">stateDescription	" *** This method was defined by Battlesnake.TileContent as a subclass responsibility.	Replace its body with a proper implementation. *** "	^'gold'</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>accessing</category><body package="Battlesnake">board	^board</body><body package="Battlesnake">board: anObject	board := anObject</body><body package="Battlesnake">cachePath: tiles to: anotherTile	^ self cachedPaths at: anotherTile put: tiles</body><body package="Battlesnake">cachedPathTo: anotherTile	^ self cachedPaths		at: anotherTile		ifPresent: [ :path | path copy ]</body><body package="Battlesnake">cachedPaths	^ cachedPaths ifNil: [ cachedPaths := IdentityDictionary new ]</body><body package="Battlesnake">content		content ifNil: [self content: EmptySpace new].	^ content</body><body package="Battlesnake">content: aTileContent	content == aTileContent ifTrue: [ ^ self ].	aTileContent ifNotNil: [ aTileContent tile: self ].	(aTileContent notNil		and: [content notNil		and: [aTileContent isSnakePart		and: [aTileContent snake == content snake ]]]) ifTrue: [ ^ self ].	content := aTileContent</body><body package="Battlesnake">east	^east</body><body package="Battlesnake">east: aTile	east == aTile ifTrue: [^self].	east := aTile.	aTile west: self</body><body package="Battlesnake">neighbourAt: offset	offset = (-1 @ 0) ifTrue: [^ west].	offset = (1 @ 0) ifTrue: [^ east].	offset = (0 @ -1) ifTrue: [^ north].	offset = (0 @ 1) ifTrue: [^ south].	^ nil</body><body package="Battlesnake">neighbours	^ neighbours ifNil: [ neighbours := (Set new: 4)		add: north;		add: east;		add: south;		add: west;		yourself]</body><body package="Battlesnake">north	^north</body><body package="Battlesnake">north: aTile	north == aTile ifTrue: [ ^ self ].	north := aTile.	aTile south: self</body><body package="Battlesnake">passingCostIn: numberOfMoves	(self mayBeTraversableIn: numberOfMoves) ifTrue: [ ^ 0 ].	"Actually, this should be a probabilistic function of the distance of other snakes on board. "		"content must be a SnakePart. Determine its tailLength, and whether it's shorter than numberOfMoves."		^ (self content tailLength &lt; numberOfMoves)		ifTrue: [ 0 ]		ifFalse: [ HighPassingCost ]</body><body package="Battlesnake">position	^position</body><body package="Battlesnake">position: aPoint	position := aPoint</body><body package="Battlesnake">probableCostIn: numberOfMoves for: aMedusa	| cost |	cost := 0.		self board snakes do: [ :eachSnake |		eachSnake == aMedusa ifFalse: [			(eachSnake head distanceTo: self) &lt; numberOfMoves ifTrue: [				]			].		].		cost</body><body package="Battlesnake">snake	^ self content snake</body><body package="Battlesnake">south	^south</body><body package="Battlesnake">south: aTile	south == aTile ifTrue: [ ^ self ].	south := aTile.	aTile north: self</body><body package="Battlesnake">tile"	For polymorphic use of certain methods, I implement tile to return self."	^ self</body><body package="Battlesnake">west	^west</body><body package="Battlesnake">west: aTile	west == aTile ifTrue: [ ^ self ].	west := aTile.	aTile east: self</body><body package="Battlesnake">x	^ position x</body><body package="Battlesnake">y	^ position y</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>converting</category><body package="Battlesnake">asDictionary	| dict |	dict := Dictionary new.	dict at: #state put: self state.	self snake ifNotNil: [ dict at: #snake put: self snake snakeName ].		^ dict</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>finding items</category><body package="Battlesnake">closestCorner	^ self		closestOf: board cornerTiles		sortedBy: [ :eachTile | self distanceTo: eachTile ]</body><body package="Battlesnake">closestCornerByPath	^ self		closestOf: board cornerTiles		sortedBy: [ :eachTile | self pathDistanceTo: eachTile ]</body><body package="Battlesnake">closestEdge	| corner rectangle |	corner := self closestCorner.	rectangle :=self position corner: corner position.		^ rectangle width abs &gt;= rectangle height abs		ifTrue: [board at: self x @ corner y ]		ifFalse: [board at: corner x @ self y ].</body><body package="Battlesnake">closestFood	^ self		closestOf: board foods		sortedBy: [ :eachFood | self distanceTo: eachFood ]</body><body package="Battlesnake">closestFoodByPath	^ self		closestOf: board foods		sortedBy: [ :eachFood | self pathDistanceTo: eachFood ]</body><body package="Battlesnake">closestGold	^ self		closestOf: board goldCoins		sortedBy: [ :eachGold | self distanceTo: eachGold ]</body><body package="Battlesnake">closestOf: items sortedBy: aBlock"	Answer the closest of the items where aBlock determines which distance we use."	items isEmpty ifTrue: [ ^ nil ].		^ (board sortItems: items by: aBlock) first</body><body package="Battlesnake">closestSnake	^ self		closestOf: board snakes		sortedBy: [ :eachSnake | self distanceTo: eachSnake ]</body><body package="Battlesnake">closestSnakeByPath	^ self		closestOf: board snakes		sortedBy: [ :eachSnake | self pathDistanceTo: eachSnake ]</body><body package="Battlesnake">farthestCorner	^ self		farthestOf: board cornerTiles		sortedBy: [ :eachTile | self distanceTo: eachTile ]</body><body package="Battlesnake">farthestEdge	| corner rectangle |	corner := self farthestCorner.	rectangle :=self position corner: corner position.		^ rectangle width abs &gt;= rectangle height abs		ifTrue: [board at: corner x @ self y ]		ifFalse: [board at: self x @ corner y ].</body><body package="Battlesnake">farthestEdgeTile	| corner rectangle |	corner := self farthestCorner.	rectangle :=self position corner: corner position.		^ rectangle width abs &lt; rectangle height abs		ifTrue: [board at: self x @ corner y ]		ifFalse: [board at: corner x @ self y ].</body><body package="Battlesnake">farthestOf: items sortedBy: aBlock"	Answer the farthest of the items where aBlock determines which distance we use."	items isEmpty ifTrue: [ ^ nil ].		^ (board sortItems: items by: aBlock) last</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>measuring</category><body package="Battlesnake">areaWithinDistance: distance"	Answer the number of tiles possible occupied within distance.	The number of unique tiles that has a NY distance given by distance.	Examples:		BoardTile new areaWithinDistance: 1.		BoardTile new areaWithinDistance: 2.		BoardTile new areaWithinDistance: 3.		BoardTile new areaWithinDistance: 10."	^ 2 * distance * (distance + 1)</body><body package="Battlesnake">distanceTo: contentOrTile	^ (contentOrTile position - self position) battlesnakeDistance</body><body package="Battlesnake">pathDistanceTo: contentOrTile	^ self pathDistanceTo: self content using: [self findPathTo: contentOrTile]</body><body package="Battlesnake">pathDistanceTo: aTileOrContent using: aBlock	^ (aBlock value: aTileOrContent) ifNotNil: [: path | path size ]</body><body package="Battlesnake">safeSpace	^safeSpace		ifNil: 			[| excluding remaining |			remaining := OrderedCollection new.			excluding := IdentitySet new.			self isSafe ifFalse: [				excluding add: self.				remaining addAll: self neighbours].			safeSpace := self safeSpaceWith: remaining excluding: excluding]</body><body package="Battlesnake">safeSpaceWith: remaining excluding: visited	|  current safe |	safe := IdentitySet new.	remaining add: self.	[remaining isEmpty] whileFalse: [		current := remaining removeFirst.		(visited includes: current) ifFalse: [			current isSafe ifTrue: [				safe add: current.				remaining addAll: current neighbours				].			visited add: current			]		].	^safe</body><body package="Battlesnake">tilesWithinDistance: distance""	| xMin xMax yMin yMax tiles  |		tiles := Set new: (self areaWithinDistance: distance).		xMin := (position x - distance) max: 0.	xMax := (position x + distance) min: board width - 1.	yMin := (position y - distance) max: 0.	yMax := (position y + distance) min: board height - 1.		xMin to: xMax do: [ :x |		| yFrom yTo xOffset |		xOffset := x - position x.		yFrom := position y - distance + xOffset abs.		yTo := position y + distance - xOffset abs.		yFrom := yFrom max: yMin.		yTo := yTo min: yMax.		yFrom to: yTo do: [ :y |			tiles add: (board at: (x @ y))			]		].		^ tiles</body><body package="Battlesnake">traversableTilesWithinDistance: distance	^ (self tilesWithinDistance: distance) select: #isTraversable</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>path finding</category><body package="Battlesnake">findPathTo: tileOrContent	| targetTile |		targetTile := tileOrContent tile.		(self cachedPathTo: targetTile) ifNotNil: [ :path | ^ path ].		^ (PathNode on: self target: targetTile) findPathToTarget ifNotNil: [ :path |		self cachePath: path to: targetTile ]</body><body package="Battlesnake">simplePathTo: targetTile"	Find which of the x,y deltas is larger, and add nodes along that axis before adding nodes along the other axis."	| path rectangle long short current corner |		path := OrderedCollection new: (self distanceTo: targetTile) + 1.	rectangle := self position corner: targetTile position.	rectangle width abs &gt;= rectangle height abs		ifTrue: [			long := rectangle width @ 0.			short := 0 @ rectangle height ]		ifFalse: [			short := rectangle width @ 0.			long := 0 @ rectangle height ].	corner := self position + long.	long := long x sign @ long y sign.	short := short x sign @ short y sign.	current := self.	(Array with: corner -&gt; long with: targetTile position -&gt; short) do: [ :cornerOffset |		| nextCorner offset |		nextCorner := cornerOffset key.		offset := cornerOffset value.		[ current position = nextCorner ] whileFalse: [			current := current neighbourAt: offset.			path add: current]		].	^path</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>accessing state</category><body package="Battlesnake">jsonState	^ Game jsonEncode: self state</body><body package="Battlesnake">state	| state |		state := OrderedCollection with: (Array with: self x with: self y).		state add: self content state.	state add: self safeSpace size.		^ state</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>printing</category><body package="Battlesnake">printOn: aStream	aStream nextPutAll: self jsonState</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>testing</category><body package="Battlesnake">hasEnemyHead	^ self hasSnakeHead and: [ self snake class = Snake ]</body><body package="Battlesnake">hasFood	^ self content isFood</body><body package="Battlesnake">hasGold	^ self content isGold</body><body package="Battlesnake">hasReward	^ self content isReward</body><body package="Battlesnake">hasSnakeHead	^ self content isSnakeHead</body><body package="Battlesnake">hasWall	^ self content isWall</body><body package="Battlesnake">isEmpty	^ self content isEmptySpace</body><body package="Battlesnake">isOccupiedBySnake	^ self content isSnakePart</body><body package="Battlesnake">isSafe	^ self isTraversable and: [		self neighbours allSatisfy: [ :tile | tile hasEnemyHead not ]		]</body><body package="Battlesnake">isTraversable	^ self content isTraversable</body><body package="Battlesnake">mayBeTraversableIn: futureTurns	^ self content mayBeTraversableIn: futureTurns</body></methods><methods><class-id>Battlesnake.BoardTile</class-id> <category>initialize-release</category><body package="Battlesnake">resetContent	content := nil.	cachedPaths := nil.	safeSpace := nil</body></methods><methods><class-id>Battlesnake.BoardTile class</class-id> <category>instance creation</category><body package="Battlesnake">on: aBoard at: aPosition	^ self new		board: aBoard;		position: aPosition;		yourself</body></methods><methods><class-id>Battlesnake.Game</class-id> <category>accessing</category><body package="Battlesnake">board	^board</body><body package="Battlesnake">board: aBoard	board := aBoard.	aBoard game: self.</body><body package="Battlesnake">foods	^board foods</body><body package="Battlesnake">gameName	^gameName</body><body package="Battlesnake">gameName: aString	gameName := aString</body><body package="Battlesnake">medusa	^medusa</body><body package="Battlesnake">snakes	^ board snakes</body><body package="Battlesnake">turn	^turn ifNil: [turn := 0]</body><body package="Battlesnake">turn: anObject	turn := anObject</body></methods><methods><class-id>Battlesnake.Game</class-id> <category>printing</category><body package="Battlesnake">printOn: aStream	aStream nextPutAll: self jsonState</body></methods><methods><class-id>Battlesnake.Game</class-id> <category>accessing state</category><body package="Battlesnake">jsonState		^ self class jsonEncode: self state</body><body package="Battlesnake">state	^ Dictionary new		at: #game_id put: gameName;		at: #turn put: turn;		at: #board put: board state;		at: #snakes put: (self snakes collect: #state);		at: #food put: (self foods values collect: [ :eachFood | Array with: eachFood x with: eachFood y]);		yourself</body><body package="Battlesnake">updateState: aState"	aState will be a Dictionary with the following keys:		game_id		turn		board		snakes		food	Since the board information is redundant to the combination of 'snakes' and 'food', we will only concern ourselves with those."	turn := aState at: #turn ifAbsent: [ self turn + 1].	board updateState: aState.	medusa := board medusa</body></methods><methods><class-id>Battlesnake.Game</class-id> <category>actions</category><body package="Battlesnake">breedMedusa	^ medusa := Medusa on: board.</body><body package="Battlesnake">medusa: aMedusa	medusa := aMedusa</body></methods><methods><class-id>Battlesnake.Game class</class-id> <category>encoding</category><body package="Battlesnake">jsonEncode: state	^ Xtreams.JSON encode: state</body></methods><methods><class-id>Battlesnake.Game class</class-id> <category>instance creation</category><body package="Battlesnake-Tests">exampleGame"	(self exampleGame)"	| board |		board := Board exampleBoard.	^ self new		gameName: 'Example Game';		board: board;		medusa: (board snakes at: 'Medusa');		turn: 0;		yourself</body><body package="Battlesnake">fromState: state""	| width height |		width := (state at: #width) asNumber.	height := (state at: #height) asNumber.		^ self new		board: (Board width: width height: height);		gameName: (state at: #game_id);		breedMedusa;		yourself</body></methods><methods><class-id>Battlesnake.PathNode</class-id> <category>accessing</category><body package="Battlesnake">costFromStart"	If it hasn't been calculated yet, determine gCost as the product of my distance from the start of the path	(the first node in the linked list) and a cost associated with a single step."	^costFromStart ifNil: [ self updateCostFromStart ]</body><body package="Battlesnake">costOfRisk	^costOfRisk ifNil: [self updateCostOfRisk ]</body><body package="Battlesnake">costOfTravel	^ costOfTravel ifNil: [ self updateCostOfTravel ]</body><body package="Battlesnake">costToTarget	^costToTarget ifNil: [ self updateCostToTarget ]</body><body package="Battlesnake">distanceFromStart"	Once a Node has a parentNode, it's distanceFromStart needs to be calculated only once."	^ distanceFromStart ifNil: [		| currentNode |			distanceFromStart := 0.		currentNode := self.		[			currentNode := currentNode parentNode.			currentNode notNil		] whileTrue: [			distanceFromStart := distanceFromStart + 1.			].		distanceFromStart ]</body><body package="Battlesnake">distanceTo: anotherNode	| offset |		offset := (anotherNode position - self position) abs.	"We can only make rectangular moves. If we were able to move diagonally, we'd have to use pythagorean theorem to calculate	the diagonal distances."	^ offset x + offset y</body><body package="Battlesnake">distanceToTarget	^ tile distanceTo: target</body><body package="Battlesnake">parentNode	^parentNode</body><body package="Battlesnake">parentNode: aPathNode	parentNode == aPathNode ifTrue: [ ^ self ].	parentNode := aPathNode.	distanceFromStart := nil.	self updateCostFromStart</body><body package="Battlesnake">position	^ tile position</body><body package="Battlesnake">stepCost"	Answer how much it costs us to make a step. Let's use 100 because it's such a nice round number."	^ 100</body><body package="Battlesnake">target	^target</body><body package="Battlesnake">target: aTile	target := aTile.	self updateCostToTarget</body><body package="Battlesnake">tile	^tile</body><body package="Battlesnake">tile: anObject	tile := anObject</body></methods><methods><class-id>Battlesnake.PathNode</class-id> <category>printing</category><body package="Battlesnake">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self position printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Battlesnake.PathNode</class-id> <category>actions</category><body package="Battlesnake">updateCostFromStart"	If it hasn't been calculated yet, determine gCost as the product of my distance from the start of the path	(the first node in the linked list) and a cost associated with a single step."	^ costFromStart := self distanceFromStart * StepCost</body><body package="Battlesnake">updateCostOfRisk"	costOfRisk is the probable cost of passing through the tile in N moves.	It is  determined by the distance of snakes from the tile.	The closer a snake is, the higher the risk will be."		costOfRisk := tile passingCostIn: self distanceFromStart.		tile board snakes do: [ :eachSnake |		eachSnake isEnemy ifTrue: [			costOfRisk := costOfRisk + (eachSnake head probabilityOfReaching: tile in: self distanceFromStart)			]		].		^ costOfRisk</body><body package="Battlesnake">updateCostOfTravel	^ costOfTravel := self costFromStart + self costToTarget + self costOfRisk</body><body package="Battlesnake">updateCostToTarget	^ costToTarget := self distanceToTarget * StepCost</body><body package="Battlesnake">updateCosts	^ self		updateCostToTarget;		updateCostOfRisk;		updateCostOfTravel</body></methods><methods><class-id>Battlesnake.PathNode</class-id> <category>initialize-release</category><body package="Battlesnake">initialize	super initialize.		costFromStart := costToTarget := 0.</body></methods><methods><class-id>Battlesnake.PathNode</class-id> <category>path finding</category><body package="Battlesnake">backtrackPath: endNode	| path backTrack |	backTrack := endNode.	path := OrderedCollection new.	[backTrack notNil] whileTrue: 			[path add: backTrack.			backTrack := backTrack parentNode].	^(path reverse collect: #tile)		removeFirst;		yourself</body><body package="Battlesnake">findPathToTarget	"	A modified version of the A* algorithm."	| remainingNodes visitedNodes nodesByTiles |	remainingNodes := SortedCollection sortBlock: [:a :b |		a costOfTravel &lt;= b costOfTravel		].	visitedNodes := IdentitySet new.	nodesByTiles := IdentityDictionary new.		nodesByTiles at: tile put: self.	remainingNodes add: self.		[remainingNodes isEmpty] whileFalse: [		| currentNode currentNeighbours |		currentNode := remainingNodes removeFirst.		visitedNodes add: currentNode.		currentNode tile == target ifTrue: [			^self backtrackPath: currentNode			].				currentNeighbours := currentNode tile neighbours sorted: [:a :b |			(a distanceTo: target) &lt;= (b distanceTo: target)].					currentNeighbours do: [:eachTile |			| node processNode |			node := nodesByTiles				at: eachTile				ifAbsentPut: [PathNode on: eachTile target: target parentNode: currentNode].								processNode := (visitedNodes includes: node) not.							((eachTile mayBeTraversableIn: node distanceFromStart) not and: [processNode]) ifTrue: [				visitedNodes add: node.				processNode := false				].						processNode ifTrue: [				|  oldCost newCost nodeInOpen|				oldCost := node costFromStart.				node updateCosts.				newCost := node costFromStart.				nodeInOpen := remainingNodes includes: node.				nodeInOpen ifTrue: [remainingNodes reSort].				(newCost &lt; oldCost or: [nodeInOpen not]) ifTrue: [					node parentNode: currentNode.					nodeInOpen ifFalse: [remainingNodes add: node]					]				]			]		].	"If I got here there is no path to targetTile. Return nil."	^nil</body></methods><methods><class-id>Battlesnake.PathNode class</class-id> <category>instance creation</category><body package="Battlesnake">new	^ super new initialize</body><body package="Battlesnake">on: aTile target: targetTile	^ self on: aTile target: targetTile parentNode: nil</body><body package="Battlesnake">on: aTile target: targetTile parentNode: aNodeOrNil	^ self new		tile: aTile;		target: targetTile;		parentNode: aNodeOrNil;		yourself</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>accessing</category><body package="Battlesnake">at: aPoint"	aPoint is a zero-based coordinate of a tile. Adjust indexes to Smalltalk one-based."	^ (rows at: aPoint y + 1) at: aPoint x + 1</body><body package="Battlesnake">bottomLeft	^ rows last first</body><body package="Battlesnake">bottomRight	^ rows last last</body><body package="Battlesnake">centre	^ self at: (self width / 2) rounded @ (self height / 2) rounded</body><body package="Battlesnake">cornerTiles	^ Array		with: self topLeft		with: self topRight		with: self bottomRight		with: self bottomLeft</body><body package="Battlesnake">dimensions	^ self width @ self height</body><body package="Battlesnake">directions	^ self class directions</body><body package="Battlesnake">foods	^foods</body><body package="Battlesnake">game	^game</body><body package="Battlesnake">game: anObject	game := anObject</body><body package="Battlesnake">goldCoins	^goldCoins</body><body package="Battlesnake">goldCoins: anObject	goldCoins := anObject</body><body package="Battlesnake">height	^ rows size</body><body package="Battlesnake">medusa	^medusa</body><body package="Battlesnake">medusa: aMedusa	medusa := aMedusa</body><body package="Battlesnake">nearBottomLeft	^ self bottomLeft north north east east</body><body package="Battlesnake">nearBottomRight	^ self bottomRight north north west west</body><body package="Battlesnake">nearTopLeft	^ self bottomLeft south south east east</body><body package="Battlesnake">nearTopRight	^ self bottomRight south south west west</body><body package="Battlesnake">quadrants"	Answer a collection of four sets where each set contains	all the tiles in each of the quadrants. Use 'ceiling' to resolve	odd number of rows and columns.		(Board defaultBoard quadrants)"	| answer rectangles extent corners |	answer := OrderedCollection new: 4.	extent := (self width / 2 - 1) floor @ (self height / 2 - 1) floor.	corners := Array		with: (0 @ 0)		with: (self width / 2) rounded @ 0		with: (0 @ (self height /  2) rounded)		with: (self width / 2) rounded @ (self height / 2) rounded.	rectangles := corners collect: [ :each | each extent: extent ].		rectangles do: [ :eachRectangle |		answer add: (self tilesInRectangle: eachRectangle)].		^ answer</body><body package="Battlesnake">rows	^rows</body><body package="Battlesnake">safestQuadrantFor: aSnake	"		(Board defaultBoard safestQuadrant)"	| quadrants |	quadrants := self traversableTilesInQuadrants.	quadrants := quadrants collect: [ :eachQuadrant |		eachQuadrant select: [ :eachTile |			aSnake tile safeSpace includes: eachTile			]		].		quadrants := quadrants sorted: [:a :b | a size &gt;= b size].	^quadrants isEmpty		ifTrue: [nil]		ifFalse: [quadrants first]</body><body package="Battlesnake">snakes	^ snakes</body><body package="Battlesnake">tilesInRectangle: aRectangle	| xMin xMax yMin yMax dX dY tiles |	xMin := aRectangle origin x.	xMax := aRectangle corner x.	yMin := aRectangle origin y.	yMax := aRectangle corner y.	dX := xMax - xMin.	dY := yMax - yMin.		tiles := OrderedCollection new: ((dX + 1) * (dY + 1)).	xMin to: xMax by: dX sign do: [ :x |		yMin to: yMax by: dY sign do: [ :y |			tiles add: (self at: x @ y)			]		].		^ tiles</body><body package="Battlesnake">topLeft	^ rows first first</body><body package="Battlesnake">topRight	^ rows first last</body><body package="Battlesnake">traversableTilesInQuadrants"	Answer a collection of four sets where each set contains	all the tiles in each of the quadrants. Use 'ceiling' to resolve	odd number of rows and columns.		(Board defaultBoard traversableTilesInQuadrants)"	^ self quadrants collect: [ :eachSet |		eachSet select: [ :eachTile | eachTile isTraversable]]</body><body package="Battlesnake">width	^ rows any size</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>initialize-release</category><body package="Battlesnake">initialize	super initialize.	snakes := Dictionary new.	self		resetFoods;		resetGoldCoins;		resetWalls</body><body package="Battlesnake">resetFoods	foods := IdentityDictionary new</body><body package="Battlesnake">resetGoldCoins	goldCoins ifNotNil: [ goldCoins do: [ :each |			each tile resetContent.			]].		goldCoins := IdentityDictionary new</body><body package="Battlesnake">resetWalls	walls := IdentityDictionary new</body><body package="Battlesnake">width: width height: height	rows := Array new: height.	"Create all the Tiles."	1 to: height do: [ :y |		| cells |		cells := Array new: width.		rows at: y put: cells.		1 to: width do: [ :x |			cells at: x put: (BoardTile on: self at: (x - 1) @ (y - 1)).			]		].		"Now link Tiles to become neighbors"	rows inject: nil into: [ :northRow :eachRow |		northRow ifNotNil: [			northRow with: eachRow do: [:northTile :eachTile |				eachTile north: northTile]			].		eachRow inject: nil into: [ :west : tile |			west ifNotNil: [tile west: west].			tile].		eachRow		]</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>actions</category><body package="Battlesnake">addSnake: aSnake	aSnake segments do: [ :each |		each tile content: each.		].		^ snakes at: aSnake snakeId put: aSnake</body><body package="Battlesnake">putFoodAt: aPoint	| tile food |	tile := self at: aPoint.	tile hasFood ifTrue: [ ^ self ].	food := Food new.	tile content: food.	foods at: tile put: food.</body><body package="Battlesnake">putGoldAt: aPoint	| tile  gold |	tile := self at: aPoint.	tile hasGold ifTrue: [ ^ self ].	gold := GoldCoin new.	tile content: gold.	goldCoins at: tile put: gold.</body><body package="Battlesnake">putWallAt: aPoint	| tile wall |	tile := self at: aPoint.	tile hasWall ifTrue: [ ^ self ].	wall := Wall new.	tile content: wall.	walls at: tile put: wall.</body><body package="Battlesnake">removeFood: aFood	foods removeKey: aFood tile ifAbsent: [nil].	aFood tile: nil</body><body package="Battlesnake">removeSnake: aSnake	aSnake segments do: [ :each |		each tile content: nil.		].		^ snakes removeKey: aSnake ifAbsent: [nil]</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>sorting</category><body package="Battlesnake">snakesByPower	^ self sortItems: self snakes by: [:eachSnake | eachSnake power]</body><body package="Battlesnake">sortItems: items by: aBlock"	Answer the closest of the items where aBlock determines which distance we use."	items isEmpty ifTrue: [ ^ #() ].		^ items sorted: [ :a :b | (aBlock value: a) &lt;= (aBlock value: b) ].</body><body package="Battlesnake">strongestSnake	| sorted |		sorted := self snakesByPower.	^ sorted isEmpty		ifTrue: [ nil ]		ifFalse: [ sorted first ]</body><body package="Battlesnake">weakestSnake	| sorted |		sorted := self snakesByPower.	^ sorted isEmpty		ifTrue: [ nil ]		ifFalse: [ sorted last ]</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>accessing state</category><body package="Battlesnake">jsonState	^ Game jsonEncode: self state</body><body package="Battlesnake">resetTileStates	self allTiles do: #resetContent.	self		resetFoods;		resetGoldCoins;		resetWalls</body><body package="Battlesnake">state"	Answer a collection of objects used to determine my state.	(self defaultBoard state)"	^ self rows collect: [ :eachRow | eachRow collect:#state ]</body><body package="Battlesnake">updateAllSnakesState: anArray myUUID: myUUID	"	From https://github.com/sendwithus/battlesnake-legacy#post-move :		  snakes:[&lt;Snake&gt;, &lt;Snake&gt;, ...]	"	| snakeIds |	snakeIds := anArray collect: [:state | state at: #id].	self snakes keys do: 			[:eachId |			(snakeIds includes: eachId)				ifFalse: [snakes removeKey: eachId ifAbsent: []]].	anArray		do: [:snakeState | self updateSingleSnakeState: snakeState myUUID: myUUID]</body><body package="Battlesnake">updateFoodState: anArray"	From https://github.com/sendwithus/battlesnake-legacy#post-move :		  food: [[1, 4], [3, 0], [5, 2]]"	anArray do: [ :each | self putFoodAt: each first @ each last ]</body><body package="Battlesnake">updateGoldState: anArray""	anArray do: [ :each | self putGoldAt: each first @ each last ]</body><body package="Battlesnake">updateState: aState	"	aState will be a Dictionary with the following keys:		game_id		turn		board		snakes		food		you	Since the board information is redundant to the combination of 'snakes' and 'food', we will only concern ourselves with those."	self resetTileStates.	self updateFoodState: (aState at: #food ifAbsent: [#()]).	self updateGoldState: (aState at: #gold ifAbsent: [#()]).	self updateWallState: (aState at: #walls ifAbsent: [#()]).	self		updateAllSnakesState: (aState at: #snakes ifAbsent: [#()])		myUUID: (aState at: #you)</body><body package="Battlesnake">updateWallState: anArray""	anArray do: [ :each | self putWallAt: each first @ each last ]</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>printing</category><body package="Battlesnake">printOn: aStream	aStream nextPutAll: self jsonState</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>testing</category><body package="Battlesnake">allTiles"	(self defaultBoard allTiles)"	^ self rows inject: OrderedCollection new into: [ :tiles :row |		tiles addAll: row;		yourself ]</body><body package="Battlesnake">isEmpty	^ self allTiles allSatisfy: [:eachTile | eachTile isEmpty]</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>tests</category><body package="Battlesnake-Tests">putTestObstacleAt: aPoint	| tile obstacle |	obstacle := TestObstacle new.	tile := self at: aPoint.	tile content: obstacle.	obstacle tile: tile.</body></methods><methods><class-id>Battlesnake.Board class</class-id> <category>instance creation</category><body package="Battlesnake">defaultBoard	^ self width: 20 height: 20</body><body package="Battlesnake-Tests">exampleBoard"	Answer a board populated with some food and snakes.	(self exampleBoard)"	| board |		board := self defaultBoard.	"Put a bunch of snakes on board"		(Snake exampleSnakes: board) do: [ :eachSnake | board addSnake: eachSnake].		"Add some foods here"	Food exampleCoordinates do: [ :eachPoint | board putFoodAt: eachPoint ].		^ board</body><body package="Battlesnake">width: width height: height	^ self new		width: width height: height;		yourself</body></methods><methods><class-id>Battlesnake.Board class</class-id> <category>accessing</category><body package="Battlesnake">directions	^ Directions</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>accessing</category><body package="Battlesnake">activeGames	^ activeGames ifNil: [activeGames := Dictionary new]</body><body package="Battlesnake">applicationClientClass		^ WormHoleClient</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>encoding - decoding</category><body package="Battlesnake">decodeFormDataRequest	| data formData |	formData := self currentRequestData.	data := JSON decode: formData data first key.		^ data</body><body package="Battlesnake">decodeJsonRequest	| data formData uri query |	formData := self currentRequestData.	query := formData data first key.	uri := URI fromEncodedString: '/?', query.	data := Dictionary new.	uri queryKeysAndValuesDo: [ :key :value |		| valueString |		valueString := URLEncoder decode: value.		data at: key asSymbol put: valueString		].		^ data</body><body package="Battlesnake">encodeFormData: data	^ JSON encode: data</body><body package="Battlesnake">encodeJsonData: data"	This is a placeholder in case we need to change our implementation depending on the XHR contentType."	^ JSON encode: data</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>game parameters</category><body package="Battlesnake">color	^ '#CFB53B'</body><body package="Battlesnake">headUrl	^ self hostAndPort, self headUrlPath</body><body package="Battlesnake">headUrlPath	"^ 'static/MedusaHead20-copy.png'"		^ 'static/Medusa-snakes-300.gif'</body><body package="Battlesnake">hostAndPort	^ 'http://vps69273.vps.ovh.ca:8889/'</body></methods><methods><class-id>Core.Point</class-id> <category>accessing</category><body package="Battlesnake">battlesnakeDistance	^ x abs + y abs</body></methods><methods><class-id>Battlesnake.Medusa</class-id> <category>accessing state</category><body package="Battlesnake">taunt	^ taunt ifNil: [Medusa randomTaunt]</body></methods><methods><class-id>Battlesnake.Board</class-id> <category>accessing state</category><body package="Battlesnake">updateSingleSnakeState: snakeState myUUID: myUUID	""	| snake snakeName snakeId |	snakeName := snakeState at: #name.	snakeId := snakeState at: #id.	snake := snakes		at: snakeId		ifAbsent: [| snakeClass |			snakeClass := snakeId = myUUID ifTrue: [Medusa] ifFalse: [Snake].			snake := (snakeClass on: self)				snakeName: snakeName;				snakeId: snakeId;				yourself.				self addSnake: snake.				snake].	^snake		updateState: snakeState;		yourself</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>configuration</category><body package="Battlesnake">serverConfiguration"	Add myself to the Battlesnake Server.	http://localhost:8889/"	&lt;position: 10&gt;	&lt;server: 'Battlesnake Server' path: '/'&gt;</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>testing API</category><body package="Battlesnake">testPage""	&lt;html: 'tester'&gt;		^ super htmlDocument</body><body package="Battlesnake">testingJs	&lt;js: 'tester/default.js'&gt;		^ '	testRequest = function testRequest(data, url) {		$.ajax({			url: url,			type: "POST",			contentType: "application/json",			data: data,			success: testSuccess		})	};		testSuccess = function testSuccess(result, status, xhr){		console.log(result);	};	testFailed = function testFailed(xhr,status,error){		console.log(xhr,status,error);	};'</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>html</category><body package="Battlesnake">bodyTester	&lt;body: 100&gt;		^ '&lt;p&gt;	&lt;a href="https://github.com/JerryKott/battlesnake"&gt;Medusa&lt;/a&gt;&lt;/p&gt;&lt;p&gt;	&lt;a href="/start?data=start%20the%20game"&gt;Send a &lt;b&gt;START&lt;/b&gt; request.&lt;/a&gt;&lt;br&gt;	&lt;a href="/move?data=send%20us%20your%20board"&gt;Send a &lt;b&gt;MOVE&lt;/b&gt; request.&lt;/a&gt;&lt;br&gt;	&lt;a href="/end?data=stop%20the%20game"&gt;Send an &lt;b&gt;END&lt;/b&gt; request.&lt;/a&gt;&lt;br&gt;&lt;/p&gt;'</body><body package="Battlesnake">headExternalLibraries	&lt;head: 200&gt;	^'	&lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"&gt;&lt;/script&gt;	&lt;script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.10.4/jquery-ui.min.js"&gt;&lt;/script&gt;'</body><body package="Battlesnake">headJQueryCss	&lt;head: 50&gt;	^'	&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;	&lt;link rel="stylesheet" href="//ajax.googleapis.com/ajax/libs/jqueryui/1.10.4/themes/humanity/jquery-ui.css" /&gt;'</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>appex overrides</category><body package="Battlesnake">appexCoreCode"	This method has been added to get access to AppeX.CoreCode.js in tester subdirectory."	&lt;js: 'tester/AppeX.CoreCode.js'&gt;		^ AppeX.CoreCode javascriptLibrary</body><body package="Battlesnake">appexWormHoleClient"	This method has been added to get access to WormHoleClient.js in tester subdirectory."	&lt;js: 'tester/Battlesnake.WormHoleClient.js'&gt;		^ self applicationClientClass javascriptLibrary</body></methods><methods><class-id>Battlesnake.WormHole class</class-id> <category>battlesnake API</category><body package="Battlesnake">end""	&lt;json: 'end'&gt;	&lt;GET&gt;	&lt;POST&gt;			| response state |		state := self decodeFormDataRequest.	response := Dictionary new.		self activeGames		removeKey: (state at: #game_id)		ifAbsent: [			^ response				at: #status put: 'No game in progress';				yourself		].				^ response</body><body package="Battlesnake">headPng""	&lt;file: 'static/Medusa-snakes-300.gif'&gt;	&lt;GET&gt;		^ (LogicalFilename named: '$(HOME)/Battlesnake') asFilename / self headUrlPath</body><body package="Battlesnake">htmlDocument"	Battlesnake rules specify that GET / returns a string with a link to our source code repository."	&lt;GET&gt;	&lt;json: ''&gt;	^ Dictionary		with: #color -&gt; self color		with: #head -&gt; self headUrl</body><body package="Battlesnake">resetGame"	(self resetGame)"	&lt;json: 'reset'&gt;	&lt;GET&gt;	&lt;POST&gt;	activeGames := nil.	Transcript clear.		^ 'Game reset!'</body><body package="Battlesnake">start""	&lt;json: 'start'&gt;	&lt;POST&gt;	| state game response |	Transcript clear.	state := self decodeFormDataRequest.	game := Game fromState: state.	self activeGames at: game gameName put: game.	response := game medusa startResponseState.	^ response</body></methods><methods><class-id>Battlesnake.WormHoleClient</class-id> <category>initialize</category><body package="Battlesnake">mainPath() {	// *** This method was defined by AppeX.ApplicationClient as a subclass responsibility.	// Replace its body with a proper implementation. *** 	this.debug('Subclass responsibility stub not reimplemented');}</body></methods><methods><class-id>Battlesnake.WormHoleClient</class-id> <category>ajax</category><body package="Battlesnake">testFailed(xhr, status, errorCode) {	console.log(xhr, status, errorCode);}</body><body package="Battlesnake">testRequest(data, url) {	var self = this,		jsonData = JSON.stringify(data);	$.ajax({		url: url,		type: "POST",		contentType: "application/x-www-form-urlencoded",		data: jsonData,		success: function(result, status, xhr) {self.testSuccess(result, status, xhr)},		error: function(xhr, status, errorCode) {self.testFailed(xhr, status, errorCode)}	})}</body><body package="Battlesnake">testSuccess(result, status, xhr){	console.log(result);}</body></methods><methods><class-id>Battlesnake.WormHoleClient</class-id> <category>test data</category><body package="Battlesnake">exampleGameData() {	return {"game_id": "Example Game", "snakes": {"Enemy 1": {"head_url": "http://head.some-snake.example/head.png", "taunt": "Taunts need to be implemented", "color": "#ff0000", "coords": [[10, 12], [10, 13], [10, 14], [10, 15]], "score": 0, "state": "alive", "name": "Enemy 1"}, "Medusa": {"head_url": "http://head.some-snake.example/head.png", "taunt": "Taunts need to be implemented", "color": "#ff0000", "coords": [[7, 8], [6, 8], [5, 8], [5, 9], [5, 10], [4, 10]], "score": 0, "state": "alive", "name": "Medusa"}, "Enemy 2": {"head_url": "http://head.some-snake.example/head.png", "taunt": "Taunts need to be implemented", "color": "#ff0000", "coords": [[11, 5], [11, 4], [10, 4], [10, 3], [10, 2], [11, 2], [12, 2], [13, 2]], "score": 0, "state": "alive", "name": "Enemy 2"}}, "turn": 0, "board": [[{"xy": [0, 0], "state": "empty"}, {"xy": [1, 0], "state": "empty"}, {"xy": [2, 0], "state": "empty"}, {"xy": [3, 0], "state": "empty"}, {"xy": [4, 0], "state": "empty"}, {"xy": [5, 0], "state": "empty"}, {"xy": [6, 0], "state": "empty"}, {"xy": [7, 0], "state": "empty"}, {"xy": [8, 0], "state": "empty"}, {"xy": [9, 0], "state": "empty"}, {"xy": [10, 0], "state": "empty"}, {"xy": [11, 0], "state": "empty"}, {"xy": [12, 0], "state": "empty"}, {"xy": [13, 0], "state": "empty"}, {"xy": [14, 0], "state": "empty"}, {"xy": [15, 0], "state": "empty"}, {"xy": [16, 0], "state": "empty"}, {"xy": [17, 0], "state": "empty"}, {"xy": [18, 0], "state": "empty"}, {"xy": [19, 0], "state": "empty"}], [{"xy": [0, 1], "state": "empty"}, {"xy": [1, 1], "state": "empty"}, {"xy": [2, 1], "state": "empty"}, {"xy": [3, 1], "state": "empty"}, {"xy": [4, 1], "state": "empty"}, {"xy": [5, 1], "state": "empty"}, {"xy": [6, 1], "state": "empty"}, {"xy": [7, 1], "state": "empty"}, {"xy": [8, 1], "state": "empty"}, {"xy": [9, 1], "state": "empty"}, {"xy": [10, 1], "state": "empty"}, {"xy": [11, 1], "state": "empty"}, {"xy": [12, 1], "state": "empty"}, {"xy": [13, 1], "state": "empty"}, {"xy": [14, 1], "state": "empty"}, {"xy": [15, 1], "state": "empty"}, {"xy": [16, 1], "state": "empty"}, {"xy": [17, 1], "state": "empty"}, {"xy": [18, 1], "state": "empty"}, {"xy": [19, 1], "state": "empty"}], [{"xy": [0, 2], "state": "empty"}, {"xy": [1, 2], "state": "empty"}, {"xy": [2, 2], "state": "food"}, {"xy": [3, 2], "state": "empty"}, {"xy": [4, 2], "state": "empty"}, {"xy": [5, 2], "state": "empty"}, {"xy": [6, 2], "state": "empty"}, {"xy": [7, 2], "state": "empty"}, {"xy": [8, 2], "state": "empty"}, {"xy": [9, 2], "state": "empty"}, {"state": "body", "xy": [10, 2], "snake": "Enemy 2"}, {"state": "body", "xy": [11, 2], "snake": "Enemy 2"}, {"state": "body", "xy": [12, 2], "snake": "Enemy 2"}, {"state": "body", "xy": [13, 2], "snake": "Enemy 2"}, {"xy": [14, 2], "state": "empty"}, {"xy": [15, 2], "state": "empty"}, {"xy": [16, 2], "state": "empty"}, {"xy": [17, 2], "state": "empty"}, {"xy": [18, 2], "state": "empty"}, {"xy": [19, 2], "state": "empty"}], [{"xy": [0, 3], "state": "empty"}, {"xy": [1, 3], "state": "empty"}, {"xy": [2, 3], "state": "empty"}, {"xy": [3, 3], "state": "empty"}, {"xy": [4, 3], "state": "empty"}, {"xy": [5, 3], "state": "empty"}, {"xy": [6, 3], "state": "empty"}, {"xy": [7, 3], "state": "empty"}, {"xy": [8, 3], "state": "empty"}, {"xy": [9, 3], "state": "empty"}, {"state": "body", "xy": [10, 3], "snake": "Enemy 2"}, {"xy": [11, 3], "state": "empty"}, {"xy": [12, 3], "state": "empty"}, {"xy": [13, 3], "state": "empty"}, {"xy": [14, 3], "state": "empty"}, {"xy": [15, 3], "state": "empty"}, {"xy": [16, 3], "state": "empty"}, {"xy": [17, 3], "state": "empty"}, {"xy": [18, 3], "state": "empty"}, {"xy": [19, 3], "state": "empty"}], [{"xy": [0, 4], "state": "empty"}, {"xy": [1, 4], "state": "empty"}, {"xy": [2, 4], "state": "empty"}, {"xy": [3, 4], "state": "empty"}, {"xy": [4, 4], "state": "empty"}, {"xy": [5, 4], "state": "empty"}, {"xy": [6, 4], "state": "empty"}, {"xy": [7, 4], "state": "empty"}, {"xy": [8, 4], "state": "empty"}, {"xy": [9, 4], "state": "empty"}, {"state": "body", "xy": [10, 4], "snake": "Enemy 2"}, {"state": "body", "xy": [11, 4], "snake": "Enemy 2"}, {"xy": [12, 4], "state": "empty"}, {"xy": [13, 4], "state": "empty"}, {"xy": [14, 4], "state": "empty"}, {"xy": [15, 4], "state": "empty"}, {"xy": [16, 4], "state": "empty"}, {"xy": [17, 4], "state": "empty"}, {"xy": [18, 4], "state": "empty"}, {"xy": [19, 4], "state": "empty"}], [{"xy": [0, 5], "state": "empty"}, {"xy": [1, 5], "state": "empty"}, {"xy": [2, 5], "state": "empty"}, {"xy": [3, 5], "state": "empty"}, {"xy": [4, 5], "state": "empty"}, {"xy": [5, 5], "state": "empty"}, {"xy": [6, 5], "state": "empty"}, {"xy": [7, 5], "state": "empty"}, {"xy": [8, 5], "state": "empty"}, {"xy": [9, 5], "state": "empty"}, {"xy": [10, 5], "state": "empty"}, {"state": "head", "xy": [11, 5], "snake": "Enemy 2"}, {"xy": [12, 5], "state": "empty"}, {"xy": [13, 5], "state": "food"}, {"xy": [14, 5], "state": "empty"}, {"xy": [15, 5], "state": "empty"}, {"xy": [16, 5], "state": "empty"}, {"xy": [17, 5], "state": "empty"}, {"xy": [18, 5], "state": "empty"}, {"xy": [19, 5], "state": "empty"}], [{"xy": [0, 6], "state": "empty"}, {"xy": [1, 6], "state": "empty"}, {"xy": [2, 6], "state": "empty"}, {"xy": [3, 6], "state": "empty"}, {"xy": [4, 6], "state": "empty"}, {"xy": [5, 6], "state": "empty"}, {"xy": [6, 6], "state": "empty"}, {"xy": [7, 6], "state": "empty"}, {"xy": [8, 6], "state": "empty"}, {"xy": [9, 6], "state": "empty"}, {"xy": [10, 6], "state": "empty"}, {"xy": [11, 6], "state": "empty"}, {"xy": [12, 6], "state": "empty"}, {"xy": [13, 6], "state": "empty"}, {"xy": [14, 6], "state": "empty"}, {"xy": [15, 6], "state": "empty"}, {"xy": [16, 6], "state": "empty"}, {"xy": [17, 6], "state": "empty"}, {"xy": [18, 6], "state": "empty"}, {"xy": [19, 6], "state": "empty"}], [{"xy": [0, 7], "state": "empty"}, {"xy": [1, 7], "state": "empty"}, {"xy": [2, 7], "state": "empty"}, {"xy": [3, 7], "state": "empty"}, {"xy": [4, 7], "state": "empty"}, {"xy": [5, 7], "state": "empty"}, {"xy": [6, 7], "state": "empty"}, {"xy": [7, 7], "state": "empty"}, {"xy": [8, 7], "state": "empty"}, {"xy": [9, 7], "state": "empty"}, {"xy": [10, 7], "state": "empty"}, {"xy": [11, 7], "state": "empty"}, {"xy": [12, 7], "state": "empty"}, {"xy": [13, 7], "state": "empty"}, {"xy": [14, 7], "state": "empty"}, {"xy": [15, 7], "state": "empty"}, {"xy": [16, 7], "state": "empty"}, {"xy": [17, 7], "state": "empty"}, {"xy": [18, 7], "state": "empty"}, {"xy": [19, 7], "state": "empty"}], [{"xy": [0, 8], "state": "empty"}, {"xy": [1, 8], "state": "empty"}, {"xy": [2, 8], "state": "empty"}, {"xy": [3, 8], "state": "empty"}, {"xy": [4, 8], "state": "empty"}, {"state": "body", "xy": [5, 8], "snake": "Medusa"}, {"state": "body", "xy": [6, 8], "snake": "Medusa"}, {"state": "head", "xy": [7, 8], "snake": "Medusa"}, {"xy": [8, 8], "state": "empty"}, {"xy": [9, 8], "state": "empty"}, {"xy": [10, 8], "state": "empty"}, {"xy": [11, 8], "state": "empty"}, {"xy": [12, 8], "state": "empty"}, {"xy": [13, 8], "state": "empty"}, {"xy": [14, 8], "state": "empty"}, {"xy": [15, 8], "state": "empty"}, {"xy": [16, 8], "state": "empty"}, {"xy": [17, 8], "state": "empty"}, {"xy": [18, 8], "state": "empty"}, {"xy": [19, 8], "state": "empty"}], [{"xy": [0, 9], "state": "empty"}, {"xy": [1, 9], "state": "empty"}, {"xy": [2, 9], "state": "empty"}, {"xy": [3, 9], "state": "empty"}, {"xy": [4, 9], "state": "empty"}, {"state": "body", "xy": [5, 9], "snake": "Medusa"}, {"xy": [6, 9], "state": "empty"}, {"xy": [7, 9], "state": "empty"}, {"xy": [8, 9], "state": "empty"}, {"xy": [9, 9], "state": "empty"}, {"xy": [10, 9], "state": "empty"}, {"xy": [11, 9], "state": "empty"}, {"xy": [12, 9], "state": "empty"}, {"xy": [13, 9], "state": "empty"}, {"xy": [14, 9], "state": "empty"}, {"xy": [15, 9], "state": "empty"}, {"xy": [16, 9], "state": "empty"}, {"xy": [17, 9], "state": "empty"}, {"xy": [18, 9], "state": "empty"}, {"xy": [19, 9], "state": "empty"}], [{"xy": [0, 10], "state": "empty"}, {"xy": [1, 10], "state": "empty"}, {"xy": [2, 10], "state": "empty"}, {"xy": [3, 10], "state": "empty"}, {"state": "body", "xy": [4, 10], "snake": "Medusa"}, {"state": "body", "xy": [5, 10], "snake": "Medusa"}, {"xy": [6, 10], "state": "empty"}, {"xy": [7, 10], "state": "empty"}, {"xy": [8, 10], "state": "empty"}, {"xy": [9, 10], "state": "empty"}, {"xy": [10, 10], "state": "empty"}, {"xy": [11, 10], "state": "empty"}, {"xy": [12, 10], "state": "empty"}, {"xy": [13, 10], "state": "empty"}, {"xy": [14, 10], "state": "empty"}, {"xy": [15, 10], "state": "empty"}, {"xy": [16, 10], "state": "empty"}, {"xy": [17, 10], "state": "empty"}, {"xy": [18, 10], "state": "empty"}, {"xy": [19, 10], "state": "empty"}], [{"xy": [0, 11], "state": "empty"}, {"xy": [1, 11], "state": "empty"}, {"xy": [2, 11], "state": "empty"}, {"xy": [3, 11], "state": "empty"}, {"xy": [4, 11], "state": "empty"}, {"xy": [5, 11], "state": "empty"}, {"xy": [6, 11], "state": "empty"}, {"xy": [7, 11], "state": "empty"}, {"xy": [8, 11], "state": "empty"}, {"xy": [9, 11], "state": "empty"}, {"xy": [10, 11], "state": "empty"}, {"xy": [11, 11], "state": "empty"}, {"xy": [12, 11], "state": "empty"}, {"xy": [13, 11], "state": "empty"}, {"xy": [14, 11], "state": "empty"}, {"xy": [15, 11], "state": "empty"}, {"xy": [16, 11], "state": "empty"}, {"xy": [17, 11], "state": "empty"}, {"xy": [18, 11], "state": "empty"}, {"xy": [19, 11], "state": "empty"}], [{"xy": [0, 12], "state": "empty"}, {"xy": [1, 12], "state": "empty"}, {"xy": [2, 12], "state": "empty"}, {"xy": [3, 12], "state": "empty"}, {"xy": [4, 12], "state": "empty"}, {"xy": [5, 12], "state": "empty"}, {"xy": [6, 12], "state": "empty"}, {"xy": [7, 12], "state": "empty"}, {"xy": [8, 12], "state": "empty"}, {"xy": [9, 12], "state": "empty"}, {"state": "head", "xy": [10, 12], "snake": "Enemy 1"}, {"xy": [11, 12], "state": "empty"}, {"xy": [12, 12], "state": "empty"}, {"xy": [13, 12], "state": "empty"}, {"xy": [14, 12], "state": "empty"}, {"xy": [15, 12], "state": "empty"}, {"xy": [16, 12], "state": "food"}, {"xy": [17, 12], "state": "empty"}, {"xy": [18, 12], "state": "empty"}, {"xy": [19, 12], "state": "empty"}], [{"xy": [0, 13], "state": "empty"}, {"xy": [1, 13], "state": "empty"}, {"xy": [2, 13], "state": "empty"}, {"xy": [3, 13], "state": "empty"}, {"xy": [4, 13], "state": "empty"}, {"xy": [5, 13], "state": "empty"}, {"xy": [6, 13], "state": "empty"}, {"xy": [7, 13], "state": "empty"}, {"xy": [8, 13], "state": "empty"}, {"xy": [9, 13], "state": "empty"}, {"state": "body", "xy": [10, 13], "snake": "Enemy 1"}, {"xy": [11, 13], "state": "empty"}, {"xy": [12, 13], "state": "empty"}, {"xy": [13, 13], "state": "empty"}, {"xy": [14, 13], "state": "empty"}, {"xy": [15, 13], "state": "empty"}, {"xy": [16, 13], "state": "empty"}, {"xy": [17, 13], "state": "empty"}, {"xy": [18, 13], "state": "empty"}, {"xy": [19, 13], "state": "empty"}], [{"xy": [0, 14], "state": "empty"}, {"xy": [1, 14], "state": "empty"}, {"xy": [2, 14], "state": "empty"}, {"xy": [3, 14], "state": "empty"}, {"xy": [4, 14], "state": "empty"}, {"xy": [5, 14], "state": "empty"}, {"xy": [6, 14], "state": "empty"}, {"xy": [7, 14], "state": "empty"}, {"xy": [8, 14], "state": "empty"}, {"xy": [9, 14], "state": "empty"}, {"state": "body", "xy": [10, 14], "snake": "Enemy 1"}, {"xy": [11, 14], "state": "empty"}, {"xy": [12, 14], "state": "empty"}, {"xy": [13, 14], "state": "empty"}, {"xy": [14, 14], "state": "empty"}, {"xy": [15, 14], "state": "empty"}, {"xy": [16, 14], "state": "empty"}, {"xy": [17, 14], "state": "empty"}, {"xy": [18, 14], "state": "empty"}, {"xy": [19, 14], "state": "empty"}], [{"xy": [0, 15], "state": "empty"}, {"xy": [1, 15], "state": "empty"}, {"xy": [2, 15], "state": "empty"}, {"xy": [3, 15], "state": "empty"}, {"xy": [4, 15], "state": "empty"}, {"xy": [5, 15], "state": "empty"}, {"xy": [6, 15], "state": "empty"}, {"xy": [7, 15], "state": "empty"}, {"xy": [8, 15], "state": "empty"}, {"xy": [9, 15], "state": "empty"}, {"state": "body", "xy": [10, 15], "snake": "Enemy 1"}, {"xy": [11, 15], "state": "empty"}, {"xy": [12, 15], "state": "empty"}, {"xy": [13, 15], "state": "empty"}, {"xy": [14, 15], "state": "empty"}, {"xy": [15, 15], "state": "empty"}, {"xy": [16, 15], "state": "empty"}, {"xy": [17, 15], "state": "empty"}, {"xy": [18, 15], "state": "empty"}, {"xy": [19, 15], "state": "empty"}], [{"xy": [0, 16], "state": "empty"}, {"xy": [1, 16], "state": "empty"}, {"xy": [2, 16], "state": "empty"}, {"xy": [3, 16], "state": "empty"}, {"xy": [4, 16], "state": "empty"}, {"xy": [5, 16], "state": "empty"}, {"xy": [6, 16], "state": "empty"}, {"xy": [7, 16], "state": "food"}, {"xy": [8, 16], "state": "empty"}, {"xy": [9, 16], "state": "empty"}, {"xy": [10, 16], "state": "empty"}, {"xy": [11, 16], "state": "empty"}, {"xy": [12, 16], "state": "empty"}, {"xy": [13, 16], "state": "empty"}, {"xy": [14, 16], "state": "empty"}, {"xy": [15, 16], "state": "empty"}, {"xy": [16, 16], "state": "food"}, {"xy": [17, 16], "state": "empty"}, {"xy": [18, 16], "state": "empty"}, {"xy": [19, 16], "state": "empty"}], [{"xy": [0, 17], "state": "empty"}, {"xy": [1, 17], "state": "empty"}, {"xy": [2, 17], "state": "empty"}, {"xy": [3, 17], "state": "empty"}, {"xy": [4, 17], "state": "empty"}, {"xy": [5, 17], "state": "empty"}, {"xy": [6, 17], "state": "empty"}, {"xy": [7, 17], "state": "empty"}, {"xy": [8, 17], "state": "empty"}, {"xy": [9, 17], "state": "empty"}, {"xy": [10, 17], "state": "empty"}, {"xy": [11, 17], "state": "empty"}, {"xy": [12, 17], "state": "empty"}, {"xy": [13, 17], "state": "empty"}, {"xy": [14, 17], "state": "empty"}, {"xy": [15, 17], "state": "empty"}, {"xy": [16, 17], "state": "empty"}, {"xy": [17, 17], "state": "empty"}, {"xy": [18, 17], "state": "empty"}, {"xy": [19, 17], "state": "empty"}], [{"xy": [0, 18], "state": "empty"}, {"xy": [1, 18], "state": "empty"}, {"xy": [2, 18], "state": "empty"}, {"xy": [3, 18], "state": "empty"}, {"xy": [4, 18], "state": "empty"}, {"xy": [5, 18], "state": "empty"}, {"xy": [6, 18], "state": "empty"}, {"xy": [7, 18], "state": "empty"}, {"xy": [8, 18], "state": "empty"}, {"xy": [9, 18], "state": "empty"}, {"xy": [10, 18], "state": "empty"}, {"xy": [11, 18], "state": "empty"}, {"xy": [12, 18], "state": "empty"}, {"xy": [13, 18], "state": "empty"}, {"xy": [14, 18], "state": "empty"}, {"xy": [15, 18], "state": "empty"}, {"xy": [16, 18], "state": "empty"}, {"xy": [17, 18], "state": "empty"}, {"xy": [18, 18], "state": "empty"}, {"xy": [19, 18], "state": "empty"}], [{"xy": [0, 19], "state": "empty"}, {"xy": [1, 19], "state": "empty"}, {"xy": [2, 19], "state": "empty"}, {"xy": [3, 19], "state": "empty"}, {"xy": [4, 19], "state": "empty"}, {"xy": [5, 19], "state": "empty"}, {"xy": [6, 19], "state": "empty"}, {"xy": [7, 19], "state": "empty"}, {"xy": [8, 19], "state": "empty"}, {"xy": [9, 19], "state": "empty"}, {"xy": [10, 19], "state": "empty"}, {"xy": [11, 19], "state": "empty"}, {"xy": [12, 19], "state": "empty"}, {"xy": [13, 19], "state": "empty"}, {"xy": [14, 19], "state": "empty"}, {"xy": [15, 19], "state": "empty"}, {"xy": [16, 19], "state": "empty"}, {"xy": [17, 19], "state": "empty"}, {"xy": [18, 19], "state": "empty"}, {"xy": [19, 19], "state": "empty"}]], "food": [[2, 2], [7, 16], [16, 16], [16, 12], [13, 5]]}}</body><body package="Battlesnake">startData() {	return {"game_id": "test-game", "width": 20, "height": 20};}</body></methods><methods><class-id>Battlesnake.WormHoleClient</class-id> <category>battlesnake API</category><body package="Battlesnake">testMove() {		this.testRequest(this.exampleGameData(), "../move");}</body><body package="Battlesnake">testStart() {	this.testRequest(this.startData(), "../start");}</body></methods><methods><class-id>SiouX.Server class</class-id> <category>configuration</category><body package="Battlesnake">battlesnakeServer: server	&lt;server: 'Battlesnake Server'&gt;	server listenOn: 8889 for: HttpConnection</body></methods><methods><class-id>AppeX.Application class</class-id> <category>html</category><body package="Battlesnake">htmlDocument	"Take the htmlTemplate and expand it to resolve the tokens in it to their actual values."	&lt;GET&gt;	&lt;json: ''&gt;	^ nil</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class><class><name>Application</name><environment>AppeX</environment><super>SiouX.HttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientSubscriptions session eventStream </inst-vars><class-inst-vars>settings requestActions subscriptionRegistry codeComposer combinedJavascriptLibrary </class-inst-vars><imports>			private Tools.Pragma			private Xtreams.*			private SiouX.*			private Protocols.*			</imports><category></category><attributes><package>AppeX-Core</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>ApplicationClient</name><environment>AppeX</environment><super>AppeX.JavascriptClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Core</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class></st-source>